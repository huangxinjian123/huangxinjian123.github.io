<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法 | 天上星星亮晶晶</title><meta name="author" content="huangxinjian"><meta name="copyright" content="huangxinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构与算法一、数据结构引论1.数据结构的基本概念：数据：人们利用文字符号、数字符号以及其他规定的符号对现实世界的事物及其活动所做的抽象描述。 数据元素：表示一个事物的一组数据。 数据项：构成数据元素的数据。 抽象数据元素：没有实际含义的数据元素。 抽象数据元素的数据类型：没有确切定义的数据类型。 数据的逻辑结构：数据元素之间的相互联系方式。 数据的存储结构：数据元素在计算机中的存储方式。 数据">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2024/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="天上星星亮晶晶">
<meta property="og:description" content="数据结构与算法一、数据结构引论1.数据结构的基本概念：数据：人们利用文字符号、数字符号以及其他规定的符号对现实世界的事物及其活动所做的抽象描述。 数据元素：表示一个事物的一组数据。 数据项：构成数据元素的数据。 抽象数据元素：没有实际含义的数据元素。 抽象数据元素的数据类型：没有确切定义的数据类型。 数据的逻辑结构：数据元素之间的相互联系方式。 数据的存储结构：数据元素在计算机中的存储方式。 数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-1328334712.cos.ap-beijing.myqcloud.com/img/R-C.png">
<meta property="article:published_time" content="2024-08-03T08:05:36.000Z">
<meta property="article:modified_time" content="2024-08-03T13:42:19.863Z">
<meta property="article:author" content="huangxinjian">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-1328334712.cos.ap-beijing.myqcloud.com/img/R-C.png"><link rel="shortcut icon" href="https://typora-1328334712.cos.ap-beijing.myqcloud.com/img/R-C.png"><link rel="canonical" href="http://example.com/2024/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-03 21:42:19'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora-1328334712.cos.ap-beijing.myqcloud.com/img/R-C.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="天上星星亮晶晶"><span class="site-name">天上星星亮晶晶</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-03T08:05:36.000Z" title="发表于 2024-08-03 16:05:36">2024-08-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-03T13:42:19.863Z" title="更新于 2024-08-03 21:42:19">2024-08-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="一、数据结构引论"><a href="#一、数据结构引论" class="headerlink" title="一、数据结构引论"></a>一、数据结构引论</h2><h3 id="1-数据结构的基本概念："><a href="#1-数据结构的基本概念：" class="headerlink" title="1.数据结构的基本概念："></a>1.数据结构的基本概念：</h3><p><strong>数据</strong>：人们利用文字符号、数字符号以及其他规定的符号对现实世界的事物及其活动所做的抽象描述。</p>
<p><strong>数据元素</strong>：表示一个事物的一组数据。</p>
<p><strong>数据项</strong>：构成数据元素的数据。</p>
<p><strong>抽象数据元素</strong>：没有实际含义的数据元素。</p>
<p><strong>抽象数据元素的数据类型</strong>：没有确切定义的数据类型。</p>
<p><strong>数据的逻辑结构</strong>：数据元素之间的相互联系方式。</p>
<p><strong>数据的存储结构</strong>：数据元素在计算机中的存储方式。</p>
<p><strong>数据的操作</strong>：对一种数据类型的数据进行的某种处理。</p>
<p><strong>数据的操作集合</strong>：对一种数据类型的数据进行的所有操作。</p>
<h3 id="2-逻辑结构"><a href="#2-逻辑结构" class="headerlink" title="2.逻辑结构"></a>2.逻辑结构</h3><p> (1) <strong>线性结构</strong>。结构中的数据元素之间存在着一对一的线性关系。除第一个和最后一个数据元素外，每个数据元素只有一个前驱和一个后继数据元素。</p>
<p> (2) <strong>树结构</strong>。结构中的数据元素之间存在着一对多的层次关系。除根结点外，每个数据元素只有一个前驱数据元素，可有０个或若干个后继数据元素。</p>
<p> (3) <strong>图结构。</strong>结构中的数据元素之间存在着多对多的任意关系。每个数据元素可有０个或若干个前驱数据元素和０个或若干个后继数据元素。</p>
<h3 id="3-数据的存储结构"><a href="#3-数据的存储结构" class="headerlink" title="3.数据的存储结构"></a>3.数据的存储结构</h3><ol>
<li>顺序存储结构：把数据元素存储在一块连续地址空间的内存中，其特点是逻辑上相邻的数据元素在物理上也相邻，数据间的逻辑关系表现在数据元素存储位置关系上。</li>
<li>指针是指向物理存储单元地址的变量。由数据元素域和指针域组成的一个结构体称为结点。</li>
<li>链式存储结构：使用指针把相互直接关联的结点(即直接前驱结点或直接后继结点)链接起来，其特点是逻辑上相邻的数据元素在物理上不一定相邻，数据间的逻辑关系表现在结点的链接关系上。</li>
</ol>
<h3 id="4-算法及其描述："><a href="#4-算法及其描述：" class="headerlink" title="4.算法及其描述："></a>4.算法及其描述：</h3><p><strong>算法的特性：</strong></p>
<p>•有穷性</p>
<p>• 确定性</p>
<p>• 可行性</p>
<p>•  输入 </p>
<p>•  输出 </p>
<p><strong>算法设计要求：</strong></p>
<p>• 正确性</p>
<p>• 可读性</p>
<p>• 健壮性</p>
<p>• 效率与低存储量需求</p>
<h2 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h2><p><img src="https://img-blog.csdnimg.cn/20190829143324547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luU3Vuc2hpbmVf,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="1-线性表的线性存储结构（数据顺序存放）"><a href="#1-线性表的线性存储结构（数据顺序存放）" class="headerlink" title="1.线性表的线性存储结构（数据顺序存放）"></a>1.线性表的线性存储结构（数据顺序存放）</h3><p><strong>前趋和后继</strong></p>
<p>当前数据之前的数据统称为“ 前趋元素 ”，前边紧挨着的数据称为“ 直接前趋 ”；</p>
<p>后继相同；</p>
<p><strong>线性表的特点</strong></p>
<p>用线性表存储的数据有两个特点：</p>
<ul>
<li>存储的数据本身的类型一定保持相同，是int型就都是int型，是结构体就都是一种结构体。</li>
<li>数据一旦用线性表存储，各个数据元素之间的相对位置就固定了。</li>
</ul>
<p><strong>代码实现：</strong></p>
<p>​	顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 20</span></span><br></pre></td></tr></table></figure>

<p><img src="https://typora-1328334712.cos.ap-beijing.myqcloud.com/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.gif" alt="线性表的线性存储结构"></p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Size 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> * head;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;table;</span><br><span class="line">table <span class="title function_">initTable</span><span class="params">()</span>&#123;</span><br><span class="line">    table t;</span><br><span class="line">    t.head=(<span class="type">int</span>*)<span class="built_in">malloc</span>(Size*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!t.head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t.length=<span class="number">0</span>;</span><br><span class="line">    t.size=Size;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出顺序表中元素的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayTable</span><span class="params">(table t)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;t.length;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t.head[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    table t=initTable();</span><br><span class="line">    <span class="comment">//向顺序表中添加元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=Size; i++) &#123;</span><br><span class="line">        t.head[i<span class="number">-1</span>]=i;</span><br><span class="line">        t.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;顺序表中存储的元素分别是：\n&quot;</span>);</span><br><span class="line">    displayTable(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序表操作：</p>
<ol>
<li><p>插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置</span></span><br><span class="line">table <span class="title function_">addTable</span><span class="params">(table t,<span class="type">int</span> elem,<span class="type">int</span> add)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）</span></span><br><span class="line">    <span class="keyword">if</span> (add&gt;t.length+<span class="number">1</span>||add&lt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置有问题\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请</span></span><br><span class="line">    <span class="keyword">if</span> (t.length==t.size) &#123;</span><br><span class="line">        t.head=(<span class="type">int</span> *)<span class="built_in">realloc</span>(t.head, (t.size+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (!t.head) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;存储分配失败\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        t.size+=<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//插入操作，需要将从插入位置开始的后续元素，逐个后移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=t.length<span class="number">-1</span>; i&gt;=add<span class="number">-1</span>; i--) &#123;</span><br><span class="line">        t.head[i+<span class="number">1</span>]=t.head[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后移完成后，直接将所需插入元素，添加到顺序表的相应位置</span></span><br><span class="line">    t.head[add<span class="number">-1</span>]=elem;</span><br><span class="line">    <span class="comment">//由于添加了元素，所以长度+1</span></span><br><span class="line">    t.length++;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">table <span class="title function_">delTable</span><span class="params">(table t,<span class="type">int</span> add)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (add&gt;t.length || add&lt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;被删除元素的位置有误\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=add; i&lt;t.length; i++) &#123;</span><br><span class="line">        t.head[i<span class="number">-1</span>]=t.head[i];</span><br><span class="line">    &#125;</span><br><span class="line">    t.length--;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>更改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更改函数，其中，elem为要更改的元素，newElem为新的数据元素</span></span><br><span class="line">table <span class="title function_">amendTable</span><span class="params">(table t,<span class="type">int</span> elem,<span class="type">int</span> newElem)</span>&#123;</span><br><span class="line">    <span class="type">int</span> add=selectTable(t, elem);</span><br><span class="line">    t.head[add<span class="number">-1</span>]=newElem;<span class="comment">//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找函数，其中，elem表示要查找的数据元素的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">selectTable</span><span class="params">(table t,<span class="type">int</span> elem)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;t.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.head[i]==elem) &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//如果查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.head=(<span class="type">int</span> *)<span class="built_in">realloc</span>(t.head, (t.size+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p><strong>动态数组额外申请更多物理空间使用的是 realloc 函数。并且，在实现后续元素整体后移的过程，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。</strong></p>
<h3 id="2-线性表的链式存储结构（数据分散存放）"><a href="#2-线性表的链式存储结构（数据分散存放）" class="headerlink" title="2.线性表的链式存储结构（数据分散存放）"></a>2.线性表的链式存储结构（数据分散存放）</h3><p><img src="https://typora-1328334712.cos.ap-beijing.myqcloud.com/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.gif" alt="线性表的链式存储"></p>
<p><strong>每个数据元素在存储时都配备一个指针，用于指向自己的直接后继元素。</strong></p>
<p><strong>头节点，头指针和首元节点</strong></p>
<p>一个完整的链表需要由以下几部分构成：</p>
<ol>
<li>头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；</li>
<li>节点：链表中的节点又细分为头节点，首元节点和其他节点：<ul>
<li>头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；</li>
<li>首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</li>
<li>其他节点：链表中其他的节点；</li>
</ul>
</li>
</ol>
<p><strong>malIoc函数的用法</strong>：在malloc.h库中，一般被包含在#include &lt;stdlib.h&gt;库中</p>
<p>p&#x3D;(int <em>)malloc (100</em>sizeof(int)); </p>
<p>它开辟100个int单元，即400字节。</p>
<p><strong>配合函数：free();</strong></p>
<p>清空内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 20;</span></span><br><span class="line"><span class="comment">//非数组 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(LinkList *head)</span>&#123;</span><br><span class="line">	*head=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//产生头节点</span></span><br><span class="line">	<span class="keyword">if</span>(!(*head))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	(*head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(LinkList head)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	LinkList p=head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(LinkList	*L)</span>&#123;</span><br><span class="line">	LinkList p,q;</span><br><span class="line">	p=(*L)-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		q=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">	(*L)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GetElem</span><span class="params">(LinkList head,<span class="type">int</span> i,ElemType *e)</span>&#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	LinkList p;</span><br><span class="line">	p=head-&gt;next;</span><br><span class="line">	j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&amp;&amp;j&lt;i)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(!p||j&gt;i)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*e=p-&gt;data;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data==e)&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(LinkList* head,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	LinkList pre,s;</span><br><span class="line">	pre=*head;</span><br><span class="line">	j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(pre&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">		pre=pre-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!pre||j!=i<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the %d\n not found&quot;</span>,i);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	s-&gt;next=pre-&gt;next;</span><br><span class="line">	pre-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(LinkList *head,<span class="type">int</span> i,ElemType *e)</span>&#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	LinkList pre,p;</span><br><span class="line">	pre=*head;</span><br><span class="line">	j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(pre-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">		pre=pre-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!(pre-&gt;next)||j!=i<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the %d\n not found&quot;</span>,i);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p=pre-&gt;next;</span><br><span class="line">	pre-&gt;next=p-&gt;next;</span><br><span class="line">	*e=p-&gt;data;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(LinkList	head)</span>&#123;</span><br><span class="line">	LinkList p=head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d   &quot;</span>,p-&gt;data);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHead</span><span class="params">(LinkList *head,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	LinkList s;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	*head=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	(*head)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">		s-&gt;data=rand()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line">		s-&gt;next=(*head)-&gt;next;</span><br><span class="line">		(*head)-&gt;next=s;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GreateTail</span><span class="params">(LinkList *head,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	LinkList s,r;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	*head=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	r=*head;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		s=(Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">		s-&gt;data=rand()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line">		r-&gt;next=s;</span><br><span class="line">		r=s;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	LinkList L;</span><br><span class="line">	ElemType e;</span><br><span class="line">	<span class="type">int</span> i,k;</span><br><span class="line">	init(&amp;L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the array length after init is LinkList(L)=%d\n&quot;</span>,length(L));</span><br><span class="line">	CreateHead(&amp;L,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;head insert&quot;</span>);</span><br><span class="line">	print(L);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">		k=Locate(L,i);</span><br><span class="line">		<span class="keyword">if</span>(k)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the %d value is %d\n&quot;</span>,k,i);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the %d not found\n&quot;</span>,i);</span><br><span class="line">	&#125; </span><br><span class="line">	Clear(&amp;L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the array length after delete is LinkList(L)=%d\n&quot;</span>,length(L));</span><br><span class="line">	GreateTail(&amp;L,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tail insert\n&quot;</span>);</span><br><span class="line">	print(L);</span><br><span class="line">	insert(&amp;L,<span class="number">2</span>,<span class="number">999</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;insert to th 999th\n&quot;</span>);</span><br><span class="line">	print(L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the address is %d\n&quot;</span>,Locate(L,<span class="number">999</span>));</span><br><span class="line">	GetElem(L,<span class="number">3</span>,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the third value is%d\n&quot;</span>,e);</span><br><span class="line">	delete(&amp;L,<span class="number">5</span>,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;删除第5个位置元素为：%d\n&quot;</span>,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;删除之后元素为：&quot;</span>);</span><br><span class="line">	print(L); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-单链表的反转：（重点）"><a href="#3-单链表的反转：（重点）" class="headerlink" title="3.单链表的反转：（重点）"></a>3.单链表的反转：（重点）</h3><p>反转链表，又可以称为翻转或逆置链表，它们表达的是同一个意思。以图 1 所示的链表为例：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U23432Z-0.gif" alt="未反转的链表"></p>
<p><strong>head的那条绿色线是1这个数据源的指针，后面依次类推。</strong></p>
<p>图 1 未反转的链表</p>
<p>经过反转（翻转、逆置）后，得到的新链表如图 2 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2344062-1.gif" alt="反转后的链表"><br>图 2 反转后的链表</p>
<p>通过对比图 1 和 图 2 中的链表不难得知，所谓反转链表，就是将链表整体“反过来”，将头变成尾、尾变成头。那么，如何实现链表的反转呢？</p>
<p>常用的实现方案有 4 种，这里分别将它们称为迭代反转法、递归反转法、就地逆置法和头插法。值得一提的是，递归反转法更适用于反转不带头节点的链表；其它 3 种方法既能反转不带头节点的链表，也能反转带头节点的链表。</p>
<p>本节将以图 1 所示，即不带头节点的链表为例，给大家详细讲解各算法的实现思想。</p>
<h4 id="1、迭代反转链表"><a href="#1、迭代反转链表" class="headerlink" title="1、迭代反转链表"></a>1、迭代反转链表</h4><p>该算法的实现思想非常直接，就是从当前链表的首元节点开始，一直遍历至链表的最后一个节点，这期间会逐个改变所遍历到的节点的指针域，另其指向前一个节点。</p>
<p>具体的实现方法也很简单，借助 3 个指针即可。以图 1 中建立的链表为例，首先我们定义 3 个指针并分别命名为 beg、mid、end。它们的初始指向如图 3 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U23460R-2.gif" alt="迭代反转链表的初始状态"><br>图 3 迭代反转链表的初始状态</p>
<p>在上图的基础上，遍历链表的过程就等价为：3 个指针每次各向后移动一个节点，直至 mid 指向链表中最后一个节点（此时 end 为 NULL ）。需要注意的是，这 3 个指针每移动之前，都需要做一步操作，即改变 mid 所指节点的指针域，另其指向和 beg 相同。</p>
<p>\1) 在图 3 的基础上，我们先改变 mid 所指节点的指针域指向，另其和 beg 相同（即改为 NULL），然后再将 3 个指针整体各向后移动一个节点。整个过程如图 4 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2345228-3.gif" alt="迭代反转链表过程一"><br>图 4 迭代反转链表过程一</p>
<p>\2) 在图 4 基础上，先改变 mid 所指节点的指针域指向，另其和 beg 相同（指向节点 1 ），再将 3 个指针整体各向后移动一个节点。整个过程如图 5 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2343502-4.gif" alt="迭代反转链表过程二"><br>图 5 迭代反转链表过程二</p>
<p>\3) 在图 5 基础上，先改变 mid 所指节点的指针域指向，另其和 beg 相同（指向节点 2 ），再将 3 个指针整体各向后移动一个节点。整个过程如图 6 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2345331-5.gif" alt="迭代反转链表过程三"><br>图 6 迭代反转链表过程三</p>
<p>\4) 图 6 中，虽然 mid 指向了原链表最后一个节点，但显然整个反转的操作还差一步，即需要最后修改一次 mid 所指节点的指针域指向，另其和 beg 相同（指向节点 3）。如图 7 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U23460G-6.gif" alt="迭代反转链表过程四"><br>图 7 迭代反转链表过程四</p>
<blockquote>
<p>注意，这里只需改变 mid 所指节点的指向即可，不用修改 3 个指针的指向。</p>
</blockquote>
<p>\5) 最后只需改变 head 头指针的指向，另其和 mid 同向，就实现了链表的反转。</p>
<p>如下是实现整个过程的代码：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U23460G-6.gif" alt="迭代反转链表过程四"></p>
<h4 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h4><p><strong>Node-&gt;next指的是该结点的指针，因为指针是连续的，所以可以通过指针找到下一个结点位置，同样只要获取头结点就获取整个链表内容；</strong>(可以理解为分散的数据被指针这根线串成一条)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代反转法，head 为无头节点链表的头指针</span></span><br><span class="line">link * <span class="title function_">iteration_reverse</span><span class="params">(link* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;<span class="comment">//理解：head==NULL代表空指针，证明没有链表，head-&gt;next==NULL这个链表只有头结点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        link * beg = <span class="literal">NULL</span>;</span><br><span class="line">        link * mid = head;</span><br><span class="line">        link * end = head-&gt;next;</span><br><span class="line">        <span class="comment">//一直遍历</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//修改 mid 所指节点的指向</span></span><br><span class="line">            mid-&gt;next = beg;</span><br><span class="line">            <span class="comment">//此时判断 end 是否为 NULL，如果成立则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (end == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//整体向后移动 3 个指针</span></span><br><span class="line">            beg = mid;</span><br><span class="line">            mid = end;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后修改 head 头指针的指向</span></span><br><span class="line">        head = mid;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、递归反转链表"><a href="#2、递归反转链表" class="headerlink" title="2、递归反转链表"></a>2、递归反转链表</h4><p>和迭代反转法的思想恰好相反，递归反转法的实现思想是从链表的尾节点开始，依次向前遍历，遍历过程依次改变各节点的指向，即另其指向前一个节点。</p>
<p>鉴于该方法的实现用到了递归算法，不易理解，因此和讲解其他实现方法不同，这里先给读者具体的实现代码，然后再给大家分析具体的实现过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">link* <span class="title function_">recursive_reverse</span><span class="params">(link* head)</span> &#123;</span><br><span class="line">    <span class="comment">//递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)     <span class="comment">// 空链或只有一个结点，直接返回头指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一直递归，找到链表中最后一个节点</span></span><br><span class="line">        link *new_head = recursive_reverse(head-&gt;next);</span><br><span class="line">        <span class="comment">//当逐层退出时，new_head 的指向都不变，一直指向原链表中最后一个节点；</span></span><br><span class="line">        <span class="comment">//递归每退出一层，函数中 head 指针的指向都会发生改变，都指向上一个节点。</span></span><br><span class="line">        <span class="comment">//每退出一层，都需要改变 head-&gt;next 节点指针域的指向，同时令 head 所指节点的指针域为 NULL。</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//每一层递归结束，都要将新的头指针返回给上一层。由此，即可保证整个递归过程中，能够一直找得到新链表的表头。</span></span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仍以图 1 中的链表为例，则整个递归实现反转的过程如下：</p>
<p>\1) 由于 head 不为 NULL，因此函数每执行到第 11 行时，递归都会深入一层，并依次将指向节点 2、3、4 的指针作为实参（head_next 的指向）参与递归。而根据递归出口的判断条件，当函数参数 head 指向的是节点 4 时满足 head-&gt;next &#x3D;&#x3D; NULL，递归过程不再深入，并返回指向节点 4 的指针，这就是反转链表的新头指针。</p>
<p>因此，当递归首次退出一层时，new_head 指向的是节点 4 ，而 head 由于退出一层，指向的是节点 3，如图 8 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2343055-7.gif" alt="递归反转链表过程一"><br>图 8 递归反转链表过程一</p>
<p>\2) 在此基础上，开始执行 17、18 行代码，整个操作过程如图 9 所示，最后将 new_head 的指向继续作为函数的返回值，传给上一层的 new_head。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U23413F-8.gif" alt="递归反转链表过程二"><br>图 9 递归反转链表过程二</p>
<blockquote>
<p>注意，图中节点 3 的 next 指针域<code>∧</code>表示为 NULL。</p>
</blockquote>
<p>\3) 再退一层，此时 new_head 仍指向节点 4，而 head 退出一层后，指向的是节点 2。在此基础上执行 17、18 行代码，并最终将 new_head 的指向作为函数返回值，继续传给上一层的 new_head。整个操作过程如图 10 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U234D49-9.gif" alt="递归反转链表过程三"><br>图 10 递归反转链表过程三</p>
<p>\4) 再退一层，此时 new_head 仍指向节点 4，而 head 退出一层后，指向的是节点 1。在此基础上执行 17、18 行代码，并返回 new_head。整个操作过程如图 11 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2345454-10.gif" alt="递归反转链表过程四"><br>图 11 递归反转链表过程四</p>
<p>head 由节点 1 进入递归，此时 head 的指向又返回到节点 1，整个递归过程结束。显然，以上过程已经实现了链表的反转，新反转链表的头指针为 new_head。</p>
<h4 id="理解：-1"><a href="#理解：-1" class="headerlink" title="理解："></a>理解：</h4><p> link *new_head &#x3D; recursive_reverse(head-&gt;next);该语句会一直执行直到获取到head-&gt;next&#x3D;4时结束。</p>
<p>为什么会结束：</p>
<p> if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL)因为该语句当传入实参为head-&gt;next为4时他的下一个结点为NULL会跳出return head;并赋给*new_head ，所以 *new_head一直等于4。</p>
<p>执行完迭代过程找到最后一个值后head为3（因为head-&gt;next为4）</p>
<p>替换过程</p>
<p>假设(1,2,3,4)为a,b,c,d，语句head-&gt;next-&gt;next &#x3D; head;</p>
<p>需要分开看，为d.next&#x3D;b</p>
<p>意思是d的指针指向b（达到两个数之间反转效果）</p>
<p>又因为 head-&gt;next &#x3D; NULL;</p>
<p>参考图：</p>
<p><img src="F:\专插本\数据结构与算法\笔记\图片\图片1.png" alt="图片1"></p>
<p>重复操作：</p>
<p>参考图：</p>
<p><img src="F:\专插本\数据结构与算法\笔记\图片\图片2.png" alt="图片2"></p>
<h4 id="3、头插法反转链表"><a href="#3、头插法反转链表" class="headerlink" title="3、头插法反转链表"></a>3、头插法反转链表</h4><p>所谓头插法，是指在原有链表的基础上，依次将位于链表头部的节点摘下，然后采用从头部插入的方式生成一个新链表，则此链表即为原链表的反转版。</p>
<p>仍以图 1 所示的链表为例，接下来为大家演示头插反转法的具体实现过程：<br>\1) 创建一个新的空链表，如图 12 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2342546-11.gif" alt="创建一个空链表"><br>图 12 创建一个空链表</p>
<p>\2) 从原链表中摘除头部节点 1，并以头部插入的方式将该节点添加到新链表中，如图 13 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2342R3-12.gif" alt="从原链表摘除节点 1，再添加到新链表中"><br>图 13 从原链表摘除节点 1，再添加到新链表中</p>
<p>\3) 从原链表中摘除头部节点 2，以头部插入的方式将该节点添加到新链表中，如图 14 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U23451H-13.gif" alt="从原链表摘除节点 2，再添加到新链表中"><br>图 14 从原链表摘除节点 2，再添加到新链表中</p>
<p>\4) 继续重复以上工作，先后将节点 3、4 从原链表中摘除，并以头部插入的方式添加到新链表中，如图 15 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U234C44-14.gif" alt="从原链表摘除节点 3、4，再添加到新链表中"><br>图 15 从原链表摘除节点 3、4，再添加到新链表中</p>
<p>由此，就实现了对原链表的反转，新反转链表的头指针为 new_head。</p>
<p>如下为以头插法实现链表反转的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">link * <span class="title function_">head_reverse</span><span class="params">(link * head)</span> &#123;</span><br><span class="line">    link * new_head = <span class="literal">NULL</span>;</span><br><span class="line">    link * temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="comment">//将 temp 从 head 中摘除</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="comment">//将 temp 插入到 new_head 的头部</span></span><br><span class="line">        temp-&gt;next = new_head;</span><br><span class="line">        new_head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、就地逆置法反转链表"><a href="#4、就地逆置法反转链表" class="headerlink" title="4、就地逆置法反转链表"></a>4、就地逆置法反转链表</h4><p>就地逆置法和头插法的实现思想类似，唯一的区别在于，头插法是通过建立一个新链表实现的，而就地逆置法则是直接对原链表做修改，从而实现将原链表反转。</p>
<p>值得一提的是，在原链表的基础上做修改，需要额外借助 2 个指针（假设分别为 beg 和 end）。仍以图 1 所示的链表为例，接下来用就地逆置法实现对该链表的反转：<br>\1) 初始状态下，令 beg 指向第一个节点，end 指向 beg-&gt;next，如图 16 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2342L7-15.gif" alt="就地反转链表的初始状态"><br>图 16 就地反转链表的初始状态</p>
<p>\2) 将 end 所指节点 2 从链表上摘除，然后再添加至当前链表的头部。如图 17 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2341592-16.gif" alt="反转节点2"><br>图 17 反转节点 2</p>
<p>\3) 将 end 指向 beg-&gt;next，然后将 end 所指节点 3 从链表摘除，再添加到当前链表的头部，如图 18 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2343N4-17.gif" alt="反转节点3"><br>图 18 反转节点 3</p>
<p>\4) 将 end 指向 beg-&gt;next，再将 end 所示节点 4 从链表摘除，并添加到当前链表的头部，如图 19 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200713/0U2342259-18.gif" alt="反转节点 4"><br>图 19 反转节点 4</p>
<p>由此，就实现了对图 1 链表的反转。 </p>
<p>具体实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">link * <span class="title function_">local_reverse</span><span class="params">(link * head)</span> &#123;</span><br><span class="line">    link * beg = <span class="literal">NULL</span>;</span><br><span class="line">    link * end = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    beg = head;</span><br><span class="line">    end = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (end != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//将 end 从链表中摘除</span></span><br><span class="line">        beg-&gt;next = end-&gt;next;</span><br><span class="line">        <span class="comment">//将 end 移动至链表头</span></span><br><span class="line">        end-&gt;next = head;</span><br><span class="line">        head = end;</span><br><span class="line">        <span class="comment">//调整 end 的指向，另其指向 beg 后的一个节点，为反转下一个节点做准备</span></span><br><span class="line">        end = beg-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="理解：-2"><a href="#理解：-2" class="headerlink" title="理解："></a>理解：</h4><p>就地逆置法：</p>
<p>分步骤做：</p>
<ol>
<li><p>定义一个beg和end</p>
</li>
<li><p>把end值取出来（也就是让beg的下一个值为end的下一个值）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beg-&gt;next = end-&gt;next;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把end取出来后和原来的head连起来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end-&gt;next = head;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再把end值变成新的头部结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = end;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后再寻找新的end值，即跟beg相邻的值成为新的end</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end=beg-&gt;next;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由此进行重复操作可得到新的排序</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节仅以无头节点的链表为例，讲解了实现链表反转的 4 种方法。实际上，对于有头节点的链表反转：</p>
<ul>
<li>使用迭代反转法实现时，初始状态忽略头节点（直接将 mid 指向首元节点），仅需在最后一步将头节点的 next 改为和 mid 同向即可；</li>
<li>使用头插法或者就地逆置法实现时，仅需将要插入的节点插入到头节点和首元节点之间即可；</li>
<li>递归法并不适用反转有头结点的链表（但并非不能实现），该方法更适用于反转无头结点的链表</li>
</ul>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p>单链表主要<strong>优点</strong>是不需要预先确定数据元素的最大个数，插入和删除操作不需要移动数据元素；</p>
<p>单链表主要<strong>缺点</strong>是查找数据元素时需要顺序进行，不能像顺序表那样随机查找任意一个数据元素。另外，每个结点中要有一个指针域，因此空间单元利用率不高。而且单链表操作的算法也较复杂。</p>
<h3 id="4-双向链表："><a href="#4-双向链表：" class="headerlink" title="4.双向链表："></a>4.双向链表：</h3><p>使用单链表无疑是灾难性的，因为单链表更适合 “从前往后” 找，而 “从后往前” 找并不是它的强项。</p>
<p>因此引进双向链表。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">line</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">line</span>* <span class="title">pre</span>;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">line</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;line;</span><br><span class="line">line* <span class="title function_">initLine</span><span class="params">(line *head)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	head=(line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(line));</span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	head-&gt;pre=<span class="literal">NULL</span>;</span><br><span class="line">	head-&gt;data=<span class="number">1</span>;</span><br><span class="line">	line* <span class="built_in">list</span>=head;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">		line* body=(line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(line));</span><br><span class="line">		body-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		body-&gt;pre=<span class="literal">NULL</span>;</span><br><span class="line">		body-&gt;data=i;</span><br><span class="line">		<span class="built_in">list</span>-&gt;next=body;</span><br><span class="line">		body-&gt;pre=<span class="built_in">list</span>;</span><br><span class="line">		<span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(line* head)</span>&#123;</span><br><span class="line">	line* temp=head;</span><br><span class="line">	<span class="keyword">while</span>(temp)&#123;</span><br><span class="line">		<span class="keyword">if</span>(temp-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,temp-&gt;data);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&lt;-&gt;&quot;</span>,temp-&gt;data);</span><br><span class="line">		&#125;</span><br><span class="line">		temp=temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	line* head=<span class="literal">NULL</span>;</span><br><span class="line">	head=initLine(head);</span><br><span class="line">	Print(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链表第四个结点的直接前驱是:%d\n&quot;</span>,head-&gt;next-&gt;next-&gt;next-&gt;pre-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码分析：</strong></p>
<p>首先创建一个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">line</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">line</span>* <span class="title">pre</span>;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">line</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;line;</span><br></pre></td></tr></table></figure>

<p>定义了该结构体的别名为line(方便后面使用)。</p>
<p>创建一个双向链表需要什么：</p>
<ol>
<li><p>首元结点：head：此时该链表只有一个首元结点（所以他没有前驱和后继）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">head=(line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(line));<span class="comment">//开辟空间放元素</span></span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">head-&gt;pre=<span class="literal">NULL</span>;</span><br><span class="line">head-&gt;data=<span class="number">1</span>;</span><br><span class="line">line* <span class="built_in">list</span>=head;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再通过递推定义其他结点 body（此时未和head连接，所以前驱和后继都为NULL）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">line* body=(line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(line));</span><br><span class="line">body-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">body-&gt;pre=<span class="literal">NULL</span>;</span><br><span class="line">body-&gt;data=i;</span><br></pre></td></tr></table></figure>


</li>
<li><p>再将他们连起来：（怎么连?l例如head的直接后继就让head的下一个结点为body，body的上一个结点为head）</p>
<p>注意点不能直接拿head操作，因为首元结点不会改变</p>
<p>因此先把首元结点赋值给定义的一个链表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line* <span class="built_in">list</span>=head;</span><br></pre></td></tr></table></figure>

<p>再进行连接操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>-&gt;next=body;</span><br><span class="line">body-&gt;pre=<span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;<span class="comment">//为放置下一个结点作准备</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-双向链表的插入操作："><a href="#1-双向链表的插入操作：" class="headerlink" title="1.双向链表的插入操作："></a>1.双向链表的插入操作：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">line * <span class="title function_">insertLine</span><span class="params">(line * head,<span class="type">int</span> data,<span class="type">int</span> add)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	line *temp=(line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(line));</span><br><span class="line">	temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	temp-&gt;pre=<span class="literal">NULL</span>;</span><br><span class="line">	temp-&gt;data=data;</span><br><span class="line">	<span class="keyword">if</span>(add==<span class="number">1</span>)&#123;</span><br><span class="line">		temp-&gt;next=head;</span><br><span class="line">		head-&gt;pre=temp;</span><br><span class="line">		head=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		line* body=head;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;add<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			body=body-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(body-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			body-&gt;next=temp;</span><br><span class="line">			temp-&gt;pre=body; </span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			body-&gt;next-&gt;pre=temp;</span><br><span class="line">			temp-&gt;next=body-&gt;next;<span class="comment">//先定死位置再插入不然无限插 </span></span><br><span class="line">			body-&gt;next=temp;</span><br><span class="line">			temp-&gt;pre=body;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码分析：</strong>（line * insertLine(line * head,int data,int add)）一定要记住做什么都要定义他的初始状态</p>
<ol>
<li><p>想要插入首先就要定义插入的结点（独立的结点，因此它的前驱和后继都为NULL,然后将数据放到该结点内）</p>
</li>
<li><p>插入要分情况：</p>
<ol>
<li><p>插头部</p>
<p>就要让插入的后继为原本的head</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp-&gt;next=head;</span><br></pre></td></tr></table></figure>

<p>原本的head的前驱是temp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head-&gt;prior=temp;</span><br></pre></td></tr></table></figure>

<p>然后让temp变成新的head</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head=temp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插中间</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1H20151Y-2.gif" alt="双向链表中间位置添加数据元素"></p>
<p>由图知道：想要插入就要将1&lt;-&gt;2断开则使插入位置的前一个结点（假设为a）的直接后驱的前驱为插入结点，再让a的后驱为temp</p>
<p>再把它们统一连接起来：</p>
<p>使temp的前驱为a,temp的后继为a的后继</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body-&gt;next-&gt;pre=temp;</span><br><span class="line">temp-&gt;next=body-&gt;next;</span><br><span class="line">body-&gt;next=temp;</span><br><span class="line">temp-&gt;pre=body;</span><br></pre></td></tr></table></figure>


</li>
<li><p>插尾部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body-&gt;next=temp;</span><br><span class="line">temp-&gt;pre=body; </span><br></pre></td></tr></table></figure>

<p>删除尾部结点，body是原链表最后一个值</p>
<p>使它的下一个结点为目标值，目标值的上一个结点为body就行了</p>
</li>
</ol>
</li>
</ol>
<h4 id="2-双向链表的删除操作："><a href="#2-双向链表的删除操作：" class="headerlink" title="2.双向链表的删除操作："></a>2.双向链表的删除操作：</h4><p><img src="http://c.biancheng.net/uploads/allimg/190426/1H2014028-4.gif" alt="双链表删除元素操作示意图"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">line * <span class="title function_">delLine</span><span class="params">(line * head,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">	line *temp=head;	</span><br><span class="line">	<span class="keyword">while</span>(temp)&#123;</span><br><span class="line">		<span class="keyword">if</span>(temp-&gt;data==data)&#123;</span><br><span class="line">		temp-&gt;pre-&gt;next=temp-&gt;next;</span><br><span class="line">		temp-&gt;next-&gt;pre=temp-&gt;pre;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	temp=temp-&gt;next;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;查无该数据&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<p>注意健壮性：</p>
<p>需要设置查无此数据时的操作。</p>
<ol>
<li><p>遍历链表查看有没有等于目标数据的结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span>(temp-&gt;data==data)&#123;</span><br><span class="line">              temp=temp-&gt;next;	</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开目标值。（将目标值的直接前驱和直接后继连起来）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp-&gt;pre-&gt;next=temp-&gt;next;</span><br><span class="line">temp-&gt;next-&gt;pre=temp-&gt;pre;</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放资源：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(temp);</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他代码为健壮性要求</p>
</li>
</ol>
<h4 id="3-双向链表的查找"><a href="#3-双向链表的查找" class="headerlink" title="3.双向链表的查找"></a>3.双向链表的查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">selectElem</span><span class="params">(line * head,<span class="type">int</span> elem)</span>&#123;</span><br><span class="line">line* temp=head;</span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(temp)&#123;</span><br><span class="line">	<span class="keyword">if</span>(temp-&gt;data==elem)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;该数据在链表的第%d个结点\n&quot;</span>,i); </span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	i++;</span><br><span class="line">	temp=temp-&gt;next;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找不到该数据所在的链表结点\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-双向表的替换"><a href="#4-双向表的替换" class="headerlink" title="4.双向表的替换"></a>4.双向表的替换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">line *<span class="title function_">amendElem</span><span class="params">(line * head,<span class="type">int</span> add,<span class="type">int</span> newElem)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	line* temp=head;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;add;i++)&#123;</span><br><span class="line">		temp=temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	temp-&gt;data=newElem;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-循环链表（实现约瑟夫环）（没思路注意看）"><a href="#5-循环链表（实现约瑟夫环）（没思路注意看）" class="headerlink" title="5.循环链表（实现约瑟夫环）（没思路注意看）"></a>5.循环链表（实现约瑟夫环）（没思路注意看）</h3><p><strong>题：</strong>约瑟夫环问题，是一个经典的循环链表问题，题意是：已知 n 个人（分别用编号 1，2，3，…，n 表示）围坐在一张圆桌周围，从编号为 k 的人开始顺时针报数，数到 m 的那个人出列；他的下一个人又从 1 开始，还是顺时针开始报数，数到 m 的那个人又出列；依次重复下去，直到圆桌上剩余一个人。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1H422E96-1.png" alt="循环链表实现约瑟夫环"></p>
<p><strong>思路：</strong></p>
<ol>
<li><strong>实现循环链表</strong>：创建一个单链表；当创建最后一个结点的时候将首元结点和它连起来。</li>
<li>找到首元结点的上一个结点将其定义为最尾部的结点（因为循环链表没有最尾的结点）（为什么需要这个，因为需要判断是不是只剩一个结点，比如说首元结点的下一个结点为尾部结点）</li>
<li>将编号为K的重新定义为尾部结点，再找报m的人，将其变为新的尾部结点，再将它删掉（记得释放内存）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;person;</span><br><span class="line">person * <span class="title function_">initLink</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">	person * head=(person*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(person));</span><br><span class="line">    head-&gt;number=<span class="number">1</span>;</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    person * cyclic=head;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        person * body=(person*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(person));</span><br><span class="line">        body-&gt;number=i;</span><br><span class="line">        body-&gt;next=<span class="literal">NULL</span>; </span><br><span class="line">        cyclic-&gt;next=body;</span><br><span class="line">        cyclic=cyclic-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cyclic-&gt;next=head;<span class="comment">//首尾相连</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">findAndKillK</span><span class="params">(person * head,<span class="type">int</span> k,<span class="type">int</span> m)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	person * tail=head;</span><br><span class="line">    <span class="comment">//找到链表第一个结点的上一个结点，为删除操作做准备</span></span><br><span class="line">    <span class="keyword">while</span> (tail-&gt;next!=head) &#123;</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    person * p=head;</span><br><span class="line">    <span class="comment">//找到编号为k的人</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;number!=k) &#123;</span><br><span class="line">        tail=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从编号为k的人开始，只有符合p-&gt;next==p时，说明链表中除了p结点，所有编号都出列了，</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next!=p) &#123;</span><br><span class="line">        <span class="comment">//找到从p报数1开始，报m的人，并且还要知道数m-1de人的位置tail，方便做删除操作。</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">            tail=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next=p-&gt;next;<span class="comment">//从链表上将p结点摘下来</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出列人的编号为:%d\n&quot;</span>,p-&gt;number);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p=tail-&gt;next;<span class="comment">//继续使用p指针指向出列编号的下一个编号，游戏继续</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出列人的编号为:%d\n&quot;</span>,p-&gt;number);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入圆桌上的人数n:&quot;</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    person * head=initLink(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从第k人开始报数(k&gt;1且k&lt;%d)：&quot;</span>,n);</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数到m的人出列：&quot;</span>);</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    findAndKillK(head, k, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码步骤：</strong></p>
<ol>
<li><p>先找到队列尾部（自定义）（链表无尾部）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person * tail=head;</span><br><span class="line">    <span class="comment">//找到链表第一个结点的上一个结点，为删除操作做准备</span></span><br><span class="line">    <span class="keyword">while</span> (tail-&gt;next!=head) &#123;</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再遍历找到k（从循环链表编号(data)为几的开始）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person * p=head;</span><br><span class="line">   <span class="comment">//找到编号为k的人</span></span><br><span class="line">   <span class="keyword">while</span> (p-&gt;number!=k) &#123;</span><br><span class="line">       tail=p;</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再从p这个起始点开始遍历直到只剩下p这个点为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从编号为k的人开始，只有符合p-&gt;next==p时，说明链表中除了p结点，所有编号都出列了，</span></span><br><span class="line">  <span class="keyword">while</span> (p-&gt;next!=p) &#123;</span><br><span class="line">      <span class="comment">//找到从p报数1开始，报m的人，并且还要知道数m-1de人的位置tail，方便做删除操作。</span></span><br><span class="line">      <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">          tail=p;</span><br><span class="line">          p=p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      tail-&gt;next=p-&gt;next;<span class="comment">//从链表上将p结点摘下来</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;出列人的编号为:%d\n&quot;</span>,p-&gt;number);</span><br><span class="line">      <span class="built_in">free</span>(p);</span><br><span class="line">      p=tail-&gt;next;<span class="comment">//继续使用p指针指向出列编号的下一个编号，游戏继续</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;出列人的编号为:%d\n&quot;</span>,p-&gt;number);</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-双向循环链表（不考）"><a href="#6-双向循环链表（不考）" class="headerlink" title="6.双向循环链表（不考）"></a>6.双向循环链表（不考）</h3><h2 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h2><p><strong>存储结构知识补充：</strong></p>
<ol>
<li>线性存储不释放内存，释放内存会添加不了内存</li>
<li>链式存储释放内存无所谓，因为是分散的</li>
</ol>
<h3 id="1-顺序栈（进栈和出栈操作）"><a href="#1-顺序栈（进栈和出栈操作）" class="headerlink" title="1.顺序栈（进栈和出栈操作）"></a>1.顺序栈（进栈和出栈操作）</h3><p>最初，栈是”空栈”，即数组是空的，top 值为初始值 -1，如图 3 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1I2034644-2.gif" alt="空栈示意图"><br>图 3 空栈示意图</p>
<p>首先向栈中添加元素 1，我们默认数组下标为 0 一端表示栈底，因此，元素 1 被存储在数组 a[1] 处，同时 top 值 +1，如图 4 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1I2033914-3.gif" alt="模拟栈存储元素 1"><br>图 4 模拟栈存储元素 1</p>
<p>采用以上的方式，依次存储元素 2、3 和 4，最终，top 值变为 3，如图 5 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1I2035P2-4.gif" alt="模拟栈存储{1,2,3,4}"><br>图 5 模拟栈存储{1,2,3,4}</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//元素elem进栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> top,<span class="type">int</span> elem)</span>&#123;</span><br><span class="line">    a[++top]=elem;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据元素出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> * a,<span class="type">int</span> top)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d\n&quot;</span>,a[top]);</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> top=<span class="number">-1</span>;</span><br><span class="line">    top=push(a, top, <span class="number">1</span>);</span><br><span class="line">    top=push(a, top, <span class="number">2</span>);</span><br><span class="line">    top=push(a, top, <span class="number">3</span>);</span><br><span class="line">    top=push(a, top, <span class="number">4</span>);</span><br><span class="line">    top=pop(a, top);</span><br><span class="line">    top=pop(a, top);</span><br><span class="line">    top=pop(a, top);</span><br><span class="line">    top=pop(a, top);</span><br><span class="line">    top=pop(a, top);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不难，就是操作数组</strong></p>
<h3 id="2-链栈（进栈和出栈操作）"><a href="#2-链栈（进栈和出栈操作）" class="headerlink" title="2.链栈（进栈和出栈操作）"></a>2.链栈（进栈和出栈操作）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linkstack</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Linkstack</span>* <span class="title">next</span>;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">&#125;Linkstack;</span><br><span class="line">Linkstack* <span class="title function_">push</span><span class="params">(Linkstack *head,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">	Linkstack *Link=(Linkstack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linkstack));</span><br><span class="line">	Link-&gt;next=head;</span><br><span class="line">	Link-&gt;data=a;</span><br><span class="line">	head=Link;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">Linkstack* <span class="title function_">pop</span><span class="params">(Linkstack *<span class="built_in">stack</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">stack</span>)&#123;</span><br><span class="line">		Linkstack *p=<span class="built_in">stack</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈元素为：%d\n&quot;</span>,p-&gt;data);</span><br><span class="line">		<span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">stack</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;新栈顶:%d\n&quot;</span>,<span class="built_in">stack</span>-&gt;data);	</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Linkstack *<span class="built_in">stack</span>=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">stack</span>=push(<span class="built_in">stack</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">stack</span>=push(<span class="built_in">stack</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">stack</span>=push(<span class="built_in">stack</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">stack</span>=push(<span class="built_in">stack</span>,<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">stack</span>=push(<span class="built_in">stack</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);	</span><br><span class="line">	<span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">	<span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">	<span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">	<span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181202/2-1Q2021G432217.gif" alt="链栈元素出栈示意图"></p>
<ol>
<li><p>push操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Linkstack* <span class="title function_">push</span><span class="params">(Linkstack *<span class="built_in">stack</span>,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">	Linkstack *Link=(Linkstack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linkstack));</span><br><span class="line">	Link-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">	Link-&gt;data=a;</span><br><span class="line">	<span class="built_in">stack</span>=Link;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合main方法理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linkstack *<span class="built_in">stack</span>=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>传入一个空指针，链表的尾巴进去</p>
<p>创建空间与传入的栈相连</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linkstack *Link=(Linkstack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linkstack));</span><br><span class="line">Link-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">Link-&gt;data=a;</span><br></pre></td></tr></table></figure>

<p>连完变成新的栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>=Link;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h2><h3 id="1-顺序队列"><a href="#1-顺序队列" class="headerlink" title="1.顺序队列"></a>1.顺序队列</h3><p>由于顺序队列的底层使用的是数组，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（<strong>top 和 rear</strong>）分别用于指向顺序队列中的队头元素和队尾元素，如图1 所示：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181204/2-1Q204202R4539.gif" alt="顺序队列实现示意图"><br>图 1<br>由于顺序队列初始状态没有存储任何元素，因此 top 指针和 rear 指针重合，且由于顺序队列底层实现靠的是数组，因此 top 和 rear 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。</p>
<p>在图 1 的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。</p>
<p>例如，在图 1 基础上将 <code>&#123;1,2,3,4&#125;</code> 用顺序队列存储的实现操作如图 2 所示：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181204/2-1Q20420293O01.gif" alt="数据进顺序队列的过程实现示意图"><br>图 2 数据进顺序队列的过程实现示意图</p>
<p>在图 2 基础上，顺序队列中数据出队列的实现过程如图 3 所示：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181204/2-1Q204202950120.gif" alt="数据出顺序队列的过程示意图"><br>图 3 数据出顺序队列的过程示意图</p>
<p>代码：</p>
<p>最简单代码（数组实现）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueIn</span><span class="params">(<span class="type">int</span> rear,<span class="type">int</span> *a,<span class="type">int</span> elem)</span>&#123;</span><br><span class="line">	a[rear]=elem;</span><br><span class="line">	rear++;</span><br><span class="line">	<span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueOut</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> rear,<span class="type">int</span> top)</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(rear!=top)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;出队顺序：%d\n&quot;</span>,a[top]);</span><br><span class="line">			top++;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> rear=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line">	rear=QueueIn(rear,a,<span class="number">1</span>);</span><br><span class="line">	rear=QueueIn(rear,a,<span class="number">2</span>);</span><br><span class="line">	rear=QueueIn(rear,a,<span class="number">3</span>);</span><br><span class="line">	rear=QueueIn(rear,a,<span class="number">4</span>);</span><br><span class="line">	rear=QueueIn(rear,a,<span class="number">5</span>);</span><br><span class="line">	QueueOut(a,rear,top);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>弊端：</strong></p>
<p>先来分析以下图 2b) 和图 3b)。图 2b) 是所有数据进队成功的示意图，而图 3b) 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，<strong>整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。</strong></p>
<h4 id="改良版：-重点"><a href="#改良版：-重点" class="headerlink" title="改良版：(重点)"></a><strong>改良版：(重点)</strong></h4><p><img src="http://data.biancheng.net/uploads/allimg/181204/2-1Q204203432215.gif" alt="环状顺序队列"></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> rear,<span class="type">int</span> top,<span class="type">int</span> *a,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((rear+<span class="number">1</span>)%Max==top)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;队列已满，无法再入队\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> rear;</span><br><span class="line">	&#125;</span><br><span class="line">	a[rear%Max]=data;</span><br><span class="line">	rear++;</span><br><span class="line">	<span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">outQueue</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> rear,<span class="type">int</span> top)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rear%Max==top)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;队列为空。\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> top; </span><br><span class="line">		&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;出队元素有：%d\n&quot;</span>,a[top]);</span><br><span class="line">			top=(top+<span class="number">1</span>)%Max;</span><br><span class="line">			<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[Max];</span><br><span class="line">	<span class="type">int</span> rear=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">	rear=enQueue(rear,top,a,<span class="number">1</span>);</span><br><span class="line">	top=outQueue(a,rear,top);</span><br><span class="line">	top=outQueue(a,rear,top);</span><br><span class="line">	rear=enQueue(rear,top,a,<span class="number">2</span>);</span><br><span class="line">	rear=enQueue(rear,top,a,<span class="number">3</span>);</span><br><span class="line">	rear=enQueue(rear,top,a,<span class="number">4</span>);</span><br><span class="line">	top=outQueue(a,rear,top);</span><br><span class="line">	top=outQueue(a,rear,top);</span><br><span class="line">	top=outQueue(a,rear,top);</span><br><span class="line">	top=outQueue(a,rear,top);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p><strong>比数组实现多了除以Max最高空间取余操作</strong></p>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(rear+<span class="number">1</span>)%Max==top<span class="comment">//代入数字可知当数据超过max时会重新开始</span></span><br></pre></td></tr></table></figure>



<h3 id="2-链式队列"><a href="#2-链式队列" class="headerlink" title="2.链式队列"></a>2.链式队列</h3><p>head，和top是无数据的</p>
<p>图解：初始化：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1I53960V-0.gif" alt="链式队列的初始状态"></p>
<p>入队（尾插）：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1I5396159-1.gif" alt="{1,2,3} 入链式队列"></p>
<p>出队：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1I5394232-2.gif" alt="链式队列中数据元素出队"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span>* <span class="title">next</span>;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">&#125;LinkStack;</span><br><span class="line">LinkStack* <span class="title function_">initQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	LinkStack* Queue=(LinkStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">	Queue-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Queue;</span><br><span class="line">&#125; </span><br><span class="line">LinkStack* <span class="title function_">enQueue</span><span class="params">(LinkStack* rear,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">	LinkStack* body=(LinkStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">	body-&gt;data=data;</span><br><span class="line">	body-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	rear-&gt;next=body;</span><br><span class="line">	rear=body;</span><br><span class="line">	<span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line">LinkStack* <span class="title function_">outQueue</span><span class="params">(LinkStack* top,LinkStack* rear)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空队列！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	LinkStack* p=top-&gt;next;</span><br><span class="line">	top-&gt;next=top-&gt;next-&gt;next;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队元素为：%d\n&quot;</span>,p-&gt;data);</span><br><span class="line">	<span class="keyword">if</span>(rear==p)&#123;</span><br><span class="line">		rear=top;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> rear;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	LinkStack * <span class="built_in">queue</span>,*top,*rear;</span><br><span class="line">    <span class="built_in">queue</span>=top=rear=initQueue();<span class="comment">//创建头结点</span></span><br><span class="line">    <span class="comment">//向链队列中添加结点，使用尾插法添加的同时，队尾指针需要指向链表的最后一个元素</span></span><br><span class="line">    rear=enQueue(rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(rear, <span class="number">2</span>);</span><br><span class="line">    rear=outQueue(top, rear);</span><br><span class="line">    rear=enQueue(rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//入队完成，所有数据元素开始出队列</span></span><br><span class="line">    rear=outQueue(top, rear);</span><br><span class="line">    rear=outQueue(top, rear);</span><br><span class="line">    rear=outQueue(top, rear);</span><br><span class="line">    rear=outQueue(top, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ol>
<li><p>初始化：看图解知（初始化关键结点rear，top和head结点）</p>
<p>注意此时head是不带数据的头结点（区别于首元结点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkStack* Queue=(LinkStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">	Queue-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Queue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入队操作：（尾插法）</p>
<p>入队时不用判断是否满队列（因为链式存储可以随时增加删除空间）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinkStack* body=(LinkStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">	body-&gt;data=data;</span><br><span class="line">	body-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	rear-&gt;next=body;<span class="comment">//rear在空栈时是和top重叠的</span></span><br><span class="line">	rear=body;</span><br><span class="line">	<span class="keyword">return</span> rear;</span><br></pre></td></tr></table></figure>

<p>先开辟空间存放数据（创建独立结点）</p>
<p>为什么这么相连可以看图解</p>
</li>
<li><p>出队操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(top-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;空队列！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">LinkStack* p=top-&gt;next;</span><br><span class="line">top-&gt;next=top-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队元素为：%d\n&quot;</span>,p-&gt;data);</span><br><span class="line"><span class="keyword">if</span>(rear==p)&#123;</span><br><span class="line">	rear=top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> rear;</span><br></pre></td></tr></table></figure>

<p>需要判断是否空队列（空了出不了队列）</p>
<p>重新定义一个p存储需要出队的结点</p>
<p>释放空间</p>
</li>
</ol>
<h2 id="五、算法及复杂度"><a href="#五、算法及复杂度" class="headerlink" title="五、算法及复杂度"></a>五、算法及复杂度</h2><h3 id="1-时间复杂度："><a href="#1-时间复杂度：" class="headerlink" title="1.时间复杂度："></a>1.时间复杂度：</h3><h2 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h2><p>字符串：字符串要单独用一种存储结构来存储，称为串存储结构。这里的串指的就是字符串。</p>
<p>串存储结构也是一种[线性存储结构，因为字符串中的字符之间也具有”一对一”的逻辑关系。只不过，与之前所学的线性存储结构不同，串结构只用于存储字符类型的数据。</p>
<p><strong>根据串中存储字符的数量及特点，对一些特殊的串进行了命名，比如说：</strong></p>
<ul>
<li>空串：存储 0 个字符的串，例如 S &#x3D; “”（双引号紧挨着）；</li>
<li>空格串：只包含空格字符的串，例如 S &#x3D; “   “（双引号包含 5 个空格）；</li>
<li>子串和主串：假设有两个串 a 和 b，如果 a 中可以找到几个连续字符组成的串与 b 完全相同，则称 a 是 b 的主串，b 是 a 的子串。例如，若 a &#x3D; “shujujiegou”，b &#x3D; “shuju”，由于 a 中也包含 “shuju”，因此串 a 和串 b 是主串和子串的关系；</li>
</ul>
<p>存储一个字符串，数据结构包含以下 3 种具体存储结构：</p>
<ol>
<li>定长顺序存储：实际上就是用普通数组（又称静态数组）存储。例如 C 语言使用普通数据存储字符串的代码为 char a[20] &#x3D; “data.biancheng.net”；</li>
<li>堆分配存储：用动态数组存储字符串；</li>
<li>块链存储：用链表存储字符串；</li>
</ol>
<h3 id="1-定长顺序存储"><a href="#1-定长顺序存储" class="headerlink" title="1.定长顺序存储"></a>1.定长顺序存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">19</span>]=<span class="string">&quot;data.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>复习：strlen():元素个数多少</p>
<p>sizeof()：空间大小</p>
<h3 id="2-堆分配存储（动态数组实现）（简单）"><a href="#2-堆分配存储（动态数组实现）（简单）" class="headerlink" title="2.堆分配存储（动态数组实现）（简单）"></a>2.堆分配存储（动态数组实现）（简单）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span>* a1=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span>* a2=<span class="literal">NULL</span>;</span><br><span class="line">	a1=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="built_in">strcpy</span>(a1,<span class="string">&quot;data.bian&quot;</span>);</span><br><span class="line">	a2=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="built_in">strcpy</span>(a2,<span class="string">&quot;cheng.net&quot;</span>);</span><br><span class="line">	<span class="type">int</span> length1=<span class="built_in">strlen</span>(a1);</span><br><span class="line">	<span class="type">int</span> length2=<span class="built_in">strlen</span>(a2);</span><br><span class="line">	<span class="keyword">if</span>(length1&gt;length1+length2)&#123;</span><br><span class="line">		length1=(<span class="type">char</span>*)<span class="built_in">realloc</span>(a1,(length1+length2)*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=length1;i&lt;length1+length2;i++)&#123;</span><br><span class="line">		a1[i]=a2[i-length1];</span><br><span class="line">	&#125;</span><br><span class="line">	a1[length1+length2]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a1);</span><br><span class="line">	<span class="built_in">free</span>(a1);</span><br><span class="line">	<span class="built_in">free</span>(a2); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<h3 id="3-块链存储（难）"><a href="#3-块链存储（难）" class="headerlink" title="3.块链存储（难）"></a>3.块链存储（难）</h3><p><img src="http://m.biancheng.net/uploads/allimg/190426/1JQ135I-1.gif" alt="各节点可存储 4 个数据元素的链表"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LinkNum 3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> a[LinkNum];<span class="comment">//LinkNum为每个节点中数据域的个数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Link</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Link;</span><br><span class="line">Link* <span class="title function_">initLink</span><span class="params">(Link *head,<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> length=<span class="built_in">strlen</span>(str);<span class="comment">//获取字符串元素个数</span></span><br><span class="line">	<span class="type">int</span> num=length/LinkNum;<span class="comment">//获取结点个数（可能会存在溢出的情况比如说19个元素，三个结点（每个结点3个数据域），这样num=3余数1，余的数需要多创建一个结点储存）</span></span><br><span class="line">	<span class="keyword">if</span>(length%LinkNum)&#123;<span class="comment">//检查余数是否为0，不为0则多创建一个结点</span></span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	head=(Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link));<span class="comment">//创建头结点(区别首元结点)</span></span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Link* temp=head;<span class="comment">//创建链表</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)&#123;<span class="comment">//先遍历创建结点</span></span><br><span class="line">		<span class="type">int</span> j=<span class="number">0</span>;<span class="comment">//注意每次遍历新的结点时(i)，j会重新从0开始</span></span><br><span class="line">		<span class="keyword">for</span>(;j&lt;LinkNum;j++)&#123;<span class="comment">//遍历创建数据域</span></span><br><span class="line">			<span class="keyword">if</span>(i*LinkNum+j&lt;length)&#123;<span class="comment">//i*LinkNum为已经使用的空间(数据域),该行代码检查是否在限定结点字符串长度中占满数据域</span></span><br><span class="line">				temp-&gt;a[j]=str[i*LinkNum+j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//未占满，但是字符串已经用完了，使用特殊符号,比如说#号填充</span></span><br><span class="line">				temp-&gt;a[j]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">		&#125;<span class="comment">//for到此结束 </span></span><br><span class="line">			<span class="keyword">if</span>(i*LinkNum+j&lt;length)&#123;</span><br><span class="line">				Link* ch=(Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link));<span class="comment">//创建结点空间</span></span><br><span class="line">				ch-&gt;next=<span class="literal">NULL</span>;<span class="comment">//创建独立的结点</span></span><br><span class="line">				temp-&gt;next=ch;<span class="comment">//将结点与创建好的链表相连</span></span><br><span class="line">				temp=ch;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(Link	*head)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	Link* p=head;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;LinkNum;i++)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Link* head=<span class="literal">NULL</span>;</span><br><span class="line">	head=initLink(head,<span class="string">&quot;data.struct.net&quot;</span>);</span><br><span class="line">	Print(head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="4-BF算法"><a href="#4-BF算法" class="headerlink" title="4.BF算法"></a>4.BF算法</h3><p>普通模式匹配算法，其实现过程没有任何技巧，就是简单粗暴地拿一个串同另一个串中的字符一一比对，得到最终结果。</p>
<p>例如，使用普通模式匹配算法判断串 A（”abcac”）是否为串 B（”ababcabacabab”）子串的判断过程如下：</p>
<p>首先，将串 A 与串 B 的首字符对齐，然后逐个判断相对的字符是否相等，如图 1 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1JZ3M04-0.gif" alt="串的第一次模式匹配示意图"><br>图 1 串的第一次模式匹配示意图</p>
<p>图 1 中，由于串 A 与串 B 的第 3 个字符匹配失败，因此需要将串 A 后移一个字符的位置，继续同串 B 匹配，如图 2 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1JZ34532-1.gif" alt="串的第二次模式匹配示意图"><br>图 2 串的第二次模式匹配示意图</p>
<p>图 2 中可以看到，两串匹配失败，串 A 继续向后移动一个字符的位置，如图 3 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1JZ35548-2.gif" alt="串的第三次模式匹配示意图"><br>图 3 串的第三次模式匹配示意图</p>
<p>图 3 中，两串的模式匹配失败，串 A 继续移动，一直移动至图 4 的位置才匹配成功：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1JZ32349-3.gif" alt="串模式匹配成功示意图"><br>图 4 串模式匹配成功示意图</p>
<p>由此，串 A 与串 B 以供经历了 6 次匹配的过程才成功，通过整个模式匹配的过程，证明了串 A 是串 B 的子串（串 B 是串 A 的主串）。</p>
<p>接下来，我们要编写代码实现两个串的模式匹配（图 1 ~图 4）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//串普通模式匹配算法的实现函数，其中 B是伪主串，A是伪子串</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mate</span><span class="params">(<span class="type">char</span> * B,<span class="type">char</span> *A)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(B) &amp;&amp; j&lt;<span class="built_in">strlen</span>(A)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i]==A[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳出循环有两种可能，i=strlen(B)说明已经遍历完主串，匹配失败；j=strlen(A),说明子串遍历完成，在主串中成功匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j==<span class="built_in">strlen</span>(A)) &#123;</span><br><span class="line">        <span class="keyword">return</span> i-<span class="built_in">strlen</span>(A)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//运行到此，为i==strlen(B)的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number=mate(<span class="string">&quot;ababcabcacbab&quot;</span>, <span class="string">&quot;abcac&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,number);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="七、树-非线性储存方式"><a href="#七、树-非线性储存方式" class="headerlink" title="七、树(非线性储存方式)"></a>七、树(非线性储存方式)</h2><p><img src="http://c.biancheng.net/uploads/allimg/190427/0944301493-0.png" alt="img"></p>
<h3 id="1-树的性质："><a href="#1-树的性质：" class="headerlink" title="1.树的性质："></a>1.树的性质：</h3><h4 id="1-树的结点"><a href="#1-树的结点" class="headerlink" title="1.树的结点"></a>1.树的结点</h4><p>结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，图 1（A）中，<strong>数据元素 A 就是一个结点</strong>；</p>
<p><strong>父结点（双亲结点）、子结点和兄弟结点</strong>：对于图 1（A）中的结点 A、B、C、D 来说，<strong>A 是</strong> B、C、D 结点的<strong>父结点</strong>（也称为“双亲结点”），而 <strong>B、C、D 都是</strong> A 结点的<strong>子结点</strong>（也称“孩子结点”）。对于 B、C、D 来说，它们都<strong>有相同的父结点，所以它们互为兄弟结点。</strong></p>
<p><strong>树根结点</strong>（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。图 1（A）中，<strong>结点 A 就是整棵树的根结点。</strong></p>
<p>树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。</p>
<p>叶子结点：<strong>如果结点没有任何子结点</strong>，那么此<strong>结点称为叶子结点（叶结点）</strong>。例如图 1（A）中，结点 K、L、F、G、M、I、J 都是这棵树的叶子结点。</p>
<h4 id="2-子树和空树（重点）"><a href="#2-子树和空树（重点）" class="headerlink" title="2.子树和空树（重点）"></a>2.子树和空树（重点）</h4><p>子树：如图 1（A）中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且节点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。</p>
<blockquote>
<p>注意：单个结点也是一棵树，只不过根结点就是它本身。图 1（A）中，结点 K、L、F 等都是树，且都是整棵树的子树。</p>
</blockquote>
<p>知道了子树的概念后，树也可以这样定义：<strong>树是由根结点和若干棵子树构成的。</strong></p>
<p>空树：<strong>如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。</strong></p>
<p>补充：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。例如，图 1（A）中，除了根结点 A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。</p>
<h4 id="3-结点的度和层次（重点）"><a href="#3-结点的度和层次（重点）" class="headerlink" title="3.结点的度和层次（重点）"></a>3.结点的度和层次（重点）</h4><p>对于一个结点，<strong>拥有的子树数（结点有多少分支）称为结点的度（Degree）。</strong>例如，图 1（A）中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。</p>
<p><strong>一棵树的度是树内各结点的度的最大值。</strong>图 1（A）表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。</p>
<p><strong>结点的层次</strong>：从一棵树的树根开始，<strong>树根所在层为第一层</strong>，根的孩子结点所在的层为第二层，依次类推。对于图 1（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。</p>
<p>一棵树的深度（高度）<strong>是树中结点所在的最大的层次</strong>。图 1（A）树的深度为 4。</p>
<p>如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，图 1（A）中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。</p>
<h4 id="4-有序树和无序树"><a href="#4-有序树和无序树" class="headerlink" title="4.有序树和无序树"></a>4.有序树和无序树</h4><p><strong>如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，</strong>这棵树称为<strong>有序树</strong>；<strong>反之称为无序树</strong>。</p>
<p>在有序树中，一个结点最左边的子树称为”第一个孩子”，最右边的称为”最后一个孩子”。</p>
<p>拿图 1（A）来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。</p>
<h4 id="5-森林"><a href="#5-森林" class="headerlink" title="5.森林"></a>5.森林</h4><p>由 m（m &gt;&#x3D; 0）个互不相交的树组成的集合被称为森林。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。</p>
<p>前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以<strong>，树还可以理解为是由根结点和森林组成的</strong>。用一个式子表示为：</p>
<p>Tree &#x3D;（root,F）</p>
<p>其中，root 表示树的根结点，F 表示由 m（m &gt;&#x3D; 0）棵树组成的森林。</p>
<h4 id="6-树的表示方法"><a href="#6-树的表示方法" class="headerlink" title="6.树的表示方法"></a>6.树的表示方法</h4><p>除了图 1（A）表示树的方法外，还有其他表示方法：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/0944303N4-1.png" alt="img"></p>
<p>​     																													（A）                     （B）</p>
<p>图2 树的表示形式</p>
<p>图 2（A）是以嵌套的集合的形式表示的（集合之间绝不能相交，即图中任意两个圈不能相交）。</p>
<p>图 2（B）使用的是凹入表示法（了解即可），表示方式是：最长条为根结点，相同长度的表示在同一层次。例如 B、C、D 长度相同，都为 A 的子结点，E 和 F 长度相同，为 B 的子结点，K 和 L 长度相同，为 E 的子结点，依此类推。</p>
<p>最常用的表示方法是使用<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3379.html">广义表</a>的方式。图 1（A）用广义表表示为：</p>
<p>(A , ( B ( E ( K , L ) , F ) , C ( G ) , D ( H ( M ) , I , J ) ) )</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>树型存储结构类似于家族的族谱，各个结点之间也同样可能具有父子、兄弟、表兄弟的关系。本节中，要重点理解树的根结点和子树的定义，同时要会计算树中各个结点的度和层次，以及树的深度。</p>
<h3 id="2-二叉树："><a href="#2-二叉树：" class="headerlink" title="2.二叉树："></a>2.二叉树：</h3><h4 id="1-二叉树定义："><a href="#1-二叉树定义：" class="headerlink" title="1.二叉树定义："></a>1.二叉树定义：</h4><p><strong>满足以下两个条件的树就是二叉树：</strong></p>
<ol>
<li>本身是<strong>有序树</strong>；</li>
<li>树中包含的各个节点的<strong>度不能超过 2</strong>，即只能是 0、1 或者 2；</li>
</ol>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/09452LR1-0.gif" alt="二叉树示意图"></p>
<h4 id="2-二叉树的性质（重点）"><a href="#2-二叉树的性质（重点）" class="headerlink" title="2.二叉树的性质（重点）"></a>2.二叉树的性质（重点）</h4><p><strong>经过前人的总结，二叉树具有以下几个性质：</strong></p>
<ol>
<li><p>二叉树中，第 i 层<strong>最多</strong>有2<sup>i-1</sup>个结点。</p>
<p>推：第一层有2<sup>0</sup>个</p>
</li>
<li><p>如果二叉树的深度为 K，那么此二叉树<strong>最多</strong>有 2<sup>k</sup>-1 个结点。</p>
<p>实在不理解就考试自己推</p>
</li>
<li><p>二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0&#x3D;n2+1。</p>
</li>
</ol>
<p>性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n&#x3D;n0+n1+n2。<br>同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n&#x3D;B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B&#x3D;n1+2<em>n2。所以，n 用另外一种方式表示为 n&#x3D;n1+2</em>n2+1。<br>两种方式得到的 n 值组成一个方程组，就可以得出 n0&#x3D;n2+1。</p>
<p>二叉树还可以继续分类，衍生出满二叉树和完全二叉树。</p>
<h4 id="3-满二叉树"><a href="#3-满二叉树" class="headerlink" title="3.满二叉树"></a>3.满二叉树</h4><p><strong>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。</strong></p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/09452HG8-1.gif" alt="满二叉树示意图"><br>图 2 满二叉树示意图</p>
<p>如图 2 所示就是一棵满二叉树。</p>
<p><strong>满二叉树除了满足普通二叉树的性质，还具有以下性质：</strong></p>
<ol>
<li>满二叉树中第 i 层的节点数为 2<sup>n-1</sup>个。</li>
<li>深度为 k 的满二叉树<strong>必有</strong> 2<sup>k</sup>-1 个节点 ，叶子数为 2<sup>k</sup>-1 。</li>
<li>满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li>
<li><strong>具有 n 个节点的满二叉树的深度为 log<sub>2</sub>(n+1)。</strong></li>
</ol>
<h4 id="4-完全二叉树"><a href="#4-完全二叉树" class="headerlink" title="4.完全二叉树"></a>4.完全二叉树</h4><p>如果二叉树中除去最后一层节点为满二叉树，<strong>且最后一层的结点依次从左到右分布</strong>，则此二叉树被称为完全二叉树。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/09452Mb5-2.gif" alt="完全二叉树示意图"><br>图 3 完全二叉树示意图（需要特别记住)</p>
<p>如图 3a) 所示是一棵完全二叉树，图 3b) 由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。</p>
<p>完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log<sub>2</sub>n⌋+1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log&lt;sub&gt;2&lt;/sub&gt;4⌋ = 2，而 ⌊log&lt;sub&gt;2&lt;/sub&gt;5⌋ 结果也是 2。</span><br></pre></td></tr></table></figure>

<p>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：</p>
<ol>
<li>当 i&gt;1 时，父亲结点为结点 [i&#x2F;2] 。（i&#x3D;1 时，表示的是根结点，无父亲结点）</li>
<li><strong>如果 2<em>i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2</em>i 。</strong></li>
<li><strong>如果 2<em>i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2</em>i+1 。</strong></li>
</ol>
<h3 id="3-二叉树的顺序存储结构"><a href="#3-二叉树的顺序存储结构" class="headerlink" title="3.二叉树的顺序存储结构"></a>3.二叉树的顺序存储结构</h3><p>二叉树的顺序存储，指的是使用<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3334.html">顺序表</a>（数组）存储二叉树。需要注意的是，顺序存储<strong>只适用于完全二叉树</strong>。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。</p>
<p>操作前需要将二叉树转为完全二叉树</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/094624M02-0.png" alt="img"></p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/094624F04-3.png" alt="img"></p>
<p>完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/0946243158-1.gif" alt="img"></p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/094624F33-2.png" alt="img"></p>
<p>不仅如此，从顺序表中还原完全二叉树也很简单。我们知道，完全二叉树具有这样的性质，将树中节点按照层次并从左到右依次标号（1,2,3,…），若节点 i 有左右孩子，则其左孩子节点为 2<em>i，右孩子节点为 2</em>i+1。此性质可用于还原数组中存储的完全二叉树，也就是实现由图 3 到图 2、由图 4 到图 1 的转变。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### <span class="number">4.</span>二叉树的链式存储结构</span><br><span class="line"></span><br><span class="line">数组不适合实现二叉树，因为不是所有二叉树都是完全二叉树。</span><br><span class="line"></span><br><span class="line">![普通二叉树示意图](http:<span class="comment">//c.biancheng.net/uploads/allimg/190427/094GL4H-0.gif)</span></span><br><span class="line"></span><br><span class="line">![二叉树链式存储结构示意图](http:<span class="comment">//c.biancheng.net/uploads/allimg/190427/094GJ2Z-1.gif)</span></span><br><span class="line"></span><br><span class="line">由图 <span class="number">2</span> 可知，采用链式存储二叉树时，其节点结构由 <span class="number">3</span> 部分构成（如图 <span class="number">3</span> 所示）：</span><br><span class="line"></span><br><span class="line">- 指向左孩子节点的指针（Lchild）；</span><br><span class="line">- 节点存储的数据（data）；</span><br><span class="line">- 指向右孩子节点的指针（Rchild）；</span><br><span class="line"></span><br><span class="line">![二叉树节点结构](http:<span class="comment">//c.biancheng.net/uploads/allimg/190427/094GK034-2.gif)</span></span><br><span class="line">图 <span class="number">3</span> 二叉树节点结构</span><br><span class="line"></span><br><span class="line">代码实现：注意结点需要开辟空间</span><br><span class="line"></span><br><span class="line">简易代码：(自己写的)</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Tree&#123;</span><br><span class="line">	<span class="keyword">struct</span> Tree* left;</span><br><span class="line">	<span class="keyword">struct</span> Tree* right;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">&#125;Tree;</span><br><span class="line">Tree* initTree(Tree* t)&#123;</span><br><span class="line">	t=(Tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">	t-&gt;data=<span class="number">1</span>;</span><br><span class="line">	t-&gt;left=(Tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">	t-&gt;right=(Tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">	t-&gt;left-&gt;data=<span class="number">2</span>;</span><br><span class="line">	t-&gt;right-&gt;data=<span class="number">3</span>;</span><br><span class="line"> 	t-&gt;left-&gt;left=(Tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line"> 	t-&gt;left-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"> 	t-&gt;left-&gt;left-&gt;data=<span class="number">4</span>;</span><br><span class="line"> 	t-&gt;left-&gt;left-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line"> 	t-&gt;left-&gt;left-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"> 	t-&gt;right-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line"> 	t-&gt;right-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="keyword">return</span> t;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> main()&#123;</span><br><span class="line">	Tree *tree=initTree(&amp;tree);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tree-&gt;left-&gt;left-&gt;data);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tree-&gt;right-&gt;data);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tree-&gt;data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>严谨写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TElemType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span>&#123;</span><br><span class="line">    *T=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;data=<span class="number">1</span>;</span><br><span class="line">    (*T)-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;data=<span class="number">2</span>;</span><br><span class="line">    (*T)-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;data=<span class="number">3</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;data=<span class="number">4</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    BiTree Tree;</span><br><span class="line">    CreateBiTree(&amp;Tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Tree-&gt;lchild-&gt;lchild-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>严谨写法中将结构体定义了两个名字。</p>
<p>BiTree表示根结点。（该变量为一个指针）</p>
<p>BiNode表示子结点。</p>
<p>主要区别在main方法中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BiTree Tree;</span><br><span class="line">CreateBiTree(&amp;Tree);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Tree-&gt;lchild-&gt;lchild-&gt;data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>初始化了一个Tree变量，将该变量丢给函数创建他的空间和它的子结点。</p>
<p><strong>三叉链表：</strong></p>
<p>在某些实际场景中，可能会做 “查找某节点的父节点” 的操作，这时可以在节点结构中再添加一个指针域，用于各个节点指向其父亲节点，如图 4 所示：（类似于双向链表）</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/094GM315-3.gif" alt="自定义二叉树的链式存储结构"><br>图 4 自定义二叉树的链式存储结构</p>
<p>这样的链表结构，通常称为三叉链表。</p>
<p>利用图 4 所示的三叉链表，我们可以很轻松地找到各节点的父节点。因此，在解决实际问题时，用合适的链表结构存储二叉树，可以起到事半功倍的效果。</p>
<h3 id="5-二叉树遍历-重点"><a href="#5-二叉树遍历-重点" class="headerlink" title="5.二叉树遍历(重点)"></a>5.二叉树遍历(重点)</h3><p><strong>非递归方式比较麻烦</strong></p>
<h4 id="1-先根遍历（递归思想）"><a href="#1-先根遍历（递归思想）" class="headerlink" title="1.先根遍历（递归思想）"></a>1.先根遍历（递归思想）</h4><p>图像：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/094T644B-0.png" alt="img"></p>
<p>以图 1 为例，采用先序遍历的思想遍历该二叉树的过程为：</p>
<ol>
<li>访问该二叉树的根节点，找到 1；</li>
<li>访问节点 1 的左子树，找到节点 2；</li>
<li>访问节点 2 的左子树，找到节点 4；</li>
<li>由于访问节点 4 左子树失败，且也没有右子树，因此以节点 4 为根节点的子树遍历完成。但节点 2 还没有遍历其右子树，因此现在开始遍历，即访问节点 5；</li>
<li>由于节点 5 无左右子树，因此节点 5 遍历完成，并且由此以节点 2 为根节点的子树也遍历完成。现在回到节点 1 ，并开始遍历该节点的右子树，即访问节点 3；</li>
<li>访问节点 3 左子树，找到节点 6；</li>
<li>由于节点 6 无左右子树，因此节点 6 遍历完成，回到节点 3 并遍历其右子树，找到节点 7；</li>
<li>节点 7 无左右子树，因此以节点 3 为根节点的子树遍历完成，同时回归节点 1。由于节点 1 的左右子树全部遍历完成，因此整个二叉树遍历完成；</li>
</ol>
<p>递归可以理解为走过的不会再走一遍</p>
<p>**代码：(递归遍历)**（简单且便利）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TElemType int</span></span><br><span class="line"><span class="comment">//构造结点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//初始化树的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span>&#123;</span><br><span class="line">    *T=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;data=<span class="number">1</span>;</span><br><span class="line">    (*T)-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">  </span><br><span class="line">    (*T)-&gt;lchild-&gt;data=<span class="number">2</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;data=<span class="number">5</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;data=<span class="number">3</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;data=<span class="number">6</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;data=<span class="number">7</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;data=<span class="number">4</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟操作结点元素的函数，输出结点本身的数值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayElem</span><span class="params">(BiTNode* elem)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,elem-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历(重点在这)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        displayElem(T);<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">        PreOrderTraverse(T -&gt;lchild);<span class="comment">//访问该结点的左孩子</span></span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);<span class="comment">//访问该结点的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    BiTree Tree;</span><br><span class="line">    CreateBiTree(&amp;Tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;先序遍历: \n&quot;</span>);</span><br><span class="line">    PreOrderTraverse(Tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归实现的一个重要的东西：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (T) &#123;</span><br><span class="line">        displayElem(T);<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);<span class="comment">//访问该结点的左孩子</span></span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);<span class="comment">//访问该结点的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>在以上的语句中，return起着关键作用（结束调用函数，继续操作）。</p>
<p>在查得到左子树时，会一直递归调用函数PreOrderTraverse(T-&gt;lchild);</p>
<p>查不到则会return;跳出递归，执行下一句： PreOrderTraverse(T-&gt;rchild);&#x2F;&#x2F;访问该结点的右孩子</p>
<p><strong>（非递归遍历）</strong></p>
<p>先根遍历的非递归思路</p>
<ul>
<li>先实现顺序栈（push，pop，getTop方法）</li>
<li>内层循环输出左子树</li>
<li>将右子树的结点压进栈内（后进先出）</li>
<li>然后再弹栈并进入内层循环输出</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TElemType int</span></span><br><span class="line"><span class="type">int</span> top=<span class="number">-1</span>;<span class="comment">//top变量时刻表示栈顶元素所在位置</span></span><br><span class="line"><span class="comment">//构造结点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//初始化树的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span>&#123;</span><br><span class="line">    *T=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;data=<span class="number">1</span>;</span><br><span class="line">    (*T)-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;data=<span class="number">2</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;data=<span class="number">5</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;data=<span class="number">3</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;data=<span class="number">6</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;data=<span class="number">7</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;data=<span class="number">4</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(BiTNode **a,BiTNode *elem)</span>&#123;</span><br><span class="line">	a[++top]=elem;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">displayElem</span><span class="params">(BiTNode* elem)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,elem-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">BiTNode* <span class="title function_">getTop</span><span class="params">(BiTNode	**a)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree Tree)</span>&#123;</span><br><span class="line">	BiTNode** a[<span class="number">20</span>];</span><br><span class="line">	BiTNode *p;</span><br><span class="line">	push(a,Tree);</span><br><span class="line">	<span class="keyword">while</span>(top!=<span class="number">-1</span>)&#123;</span><br><span class="line">		p=getTop(a);</span><br><span class="line">		pop();</span><br><span class="line">		<span class="keyword">while</span>(p)&#123;</span><br><span class="line">			displayElem(p);</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;rchild)&#123;</span><br><span class="line">				push(a,p-&gt;rchild);</span><br><span class="line">			&#125;</span><br><span class="line">			p=p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    BiTree Tree;</span><br><span class="line">    CreateBiTree(&amp;Tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;先序遍历: \n&quot;</span>);</span><br><span class="line">    PreOrderTraverse(Tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-中根遍历"><a href="#2-中根遍历" class="headerlink" title="2.中根遍历"></a>2.中根遍历</h4><p><img src="https://typora-1328334712.cos.ap-beijing.myqcloud.com/img/image-20220508110749583.png" alt="image-20220508110749583"></p>
<p><strong>递归写法：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TElemType int</span></span><br><span class="line"><span class="comment">//构造结点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//初始化树的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span>&#123;</span><br><span class="line">    *T=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;data=<span class="number">1</span>;</span><br><span class="line">    (*T)-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">  </span><br><span class="line">    (*T)-&gt;lchild-&gt;data=<span class="number">2</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;data=<span class="number">5</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;data=<span class="number">3</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;data=<span class="number">6</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;data=<span class="number">7</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;data=<span class="number">4</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟操作结点元素的函数，输出结点本身的数值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayElem</span><span class="params">(BiTNode* elem)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,elem-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">INOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        INOrderTraverse(T-&gt;lchild);<span class="comment">//遍历左孩子</span></span><br><span class="line">        displayElem(T);<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">        INOrderTraverse(T-&gt;rchild);<span class="comment">//遍历右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    BiTree Tree;</span><br><span class="line">    CreateBiTree(&amp;Tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历算法: \n&quot;</span>);</span><br><span class="line">    INOrderTraverse(Tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>非递归写法：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TElemType int</span></span><br><span class="line"><span class="type">int</span> top=<span class="number">-1</span>;<span class="comment">//top变量时刻表示栈顶元素所在位置</span></span><br><span class="line"><span class="comment">//构造结点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//初始化树的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span>&#123;</span><br><span class="line">    *T=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;data=<span class="number">1</span>;</span><br><span class="line">    (*T)-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;data=<span class="number">2</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;data=<span class="number">5</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;data=<span class="number">3</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;data=<span class="number">6</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;data=<span class="number">7</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;data=<span class="number">4</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序和中序遍历使用的进栈函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(BiTNode** a,BiTNode* elem)</span>&#123;</span><br><span class="line">    a[++top]=elem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弹栈函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟操作结点元素的函数，输出结点本身的数值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayElem</span><span class="params">(BiTNode* elem)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,elem-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拿到栈顶元素</span></span><br><span class="line">BiTNode* <span class="title function_">getTop</span><span class="params">(BiTNode**a)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历非递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse1</span><span class="params">(BiTree Tree)</span>&#123;</span><br><span class="line">    BiTNode* a[<span class="number">20</span>];<span class="comment">//定义一个顺序栈</span></span><br><span class="line">    BiTNode * p;<span class="comment">//临时指针</span></span><br><span class="line">    push(a, Tree);<span class="comment">//根结点进栈</span></span><br><span class="line">    <span class="keyword">while</span> (top!=<span class="number">-1</span>) &#123;<span class="comment">//top!=-1说明栈内不为空，程序继续运行</span></span><br><span class="line">        <span class="keyword">while</span> ((p=getTop(a)) &amp;&amp;p)&#123;<span class="comment">//取栈顶元素，且不能为NULL</span></span><br><span class="line">            push(a, p-&gt;lchild);<span class="comment">//将该结点的左孩子进栈，如果没有左孩子，NULL进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        pop();<span class="comment">//跳出循环，栈顶元素肯定为NULL，将NULL弹栈</span></span><br><span class="line">        <span class="keyword">if</span> (top!=<span class="number">-1</span>) &#123;</span><br><span class="line">            p=getTop(a);<span class="comment">//取栈顶元素</span></span><br><span class="line">            pop();<span class="comment">//栈顶元素弹栈</span></span><br><span class="line">            displayElem(p);</span><br><span class="line">            push(a, p-&gt;rchild);<span class="comment">//将p指向的结点的右孩子进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历实现的另一种方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse2</span><span class="params">(BiTree Tree)</span>&#123;</span><br><span class="line">    BiTNode* a[<span class="number">20</span>];<span class="comment">//定义一个顺序栈</span></span><br><span class="line">    BiTNode * p;<span class="comment">//临时指针</span></span><br><span class="line">    p=Tree;</span><br><span class="line">    <span class="comment">//当p为NULL或者栈为空时，表明树遍历完成</span></span><br><span class="line">    <span class="keyword">while</span> (p || top!=<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果p不为NULL，将其压栈并遍历其左子树</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            push(a, p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果p==NULL，表明左子树遍历完成，需要遍历上一层结点的右子树</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p=getTop(a);</span><br><span class="line">            pop();</span><br><span class="line">            displayElem(p);</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    BiTree Tree;</span><br><span class="line">    CreateBiTree(&amp;Tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历算法1: \n&quot;</span>);</span><br><span class="line">    InOrderTraverse1(Tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历算法2: \n&quot;</span>);</span><br><span class="line">    InOrderTraverse2(Tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-后根遍历"><a href="#3-后根遍历" class="headerlink" title="3.后根遍历"></a>3.后根遍历</h4><p><strong>递归遍历：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TElemType int</span></span><br><span class="line"><span class="comment">//构造结点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//初始化树的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span>&#123;</span><br><span class="line">    *T=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;data=<span class="number">1</span>;</span><br><span class="line">    (*T)-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">  </span><br><span class="line">    (*T)-&gt;lchild-&gt;data=<span class="number">2</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;data=<span class="number">5</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;data=<span class="number">3</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;data=<span class="number">6</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;data=<span class="number">7</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;data=<span class="number">4</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟操作结点元素的函数，输出结点本身的数值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayElem</span><span class="params">(BiTNode* elem)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,elem-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        PostOrderTraverse(T-&gt;lchild);<span class="comment">//遍历左孩子</span></span><br><span class="line">        PostOrderTraverse(T-&gt;rchild);<span class="comment">//遍历右孩子</span></span><br><span class="line">        displayElem(T);<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    BiTree Tree;</span><br><span class="line">    CreateBiTree(&amp;Tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;后序遍历: \n&quot;</span>);</span><br><span class="line">    PostOrderTraverse(Tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-层次遍历"><a href="#4-层次遍历" class="headerlink" title="4.层次遍历"></a>4.层次遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TElemType int</span></span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> rear=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span>&#123;</span><br><span class="line">    *T=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;data=<span class="number">1</span>;</span><br><span class="line">    (*T)-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">   </span><br><span class="line">    (*T)-&gt;lchild-&gt;data=<span class="number">2</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;data=<span class="number">5</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">    (*T)-&gt;rchild-&gt;data=<span class="number">3</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;data=<span class="number">6</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;data=<span class="number">7</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;data=<span class="number">4</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(BiTree *a,BiTree node)</span>&#123;</span><br><span class="line">	a[rear++]=node;</span><br><span class="line">&#125;</span><br><span class="line">BiTNode* <span class="title function_">DeQueue</span><span class="params">(BiTNode** a)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[top++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">displayNode</span><span class="params">(BiTree node)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	BiTree tree;</span><br><span class="line">	CreateBiTree(&amp;tree);</span><br><span class="line">	BiTNode* p;</span><br><span class="line">	BiTree a[<span class="number">20</span>];</span><br><span class="line">	EnQueue(a,tree);</span><br><span class="line">	<span class="keyword">while</span>(top&lt;rear)&#123;</span><br><span class="line">		p=DeQueue(a);</span><br><span class="line">		displayNode(p);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			EnQueue(a,p-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			EnQueue(a,p-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(top&lt;rear)&#123;</span><br><span class="line">		p=DeQueue(a);</span><br><span class="line">		displayNode(p);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			EnQueue(a,p-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			EnQueue(a,p-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>top&#x3D;&#x3D;rear时队列为空</p>
<p>将队列头出列且赋给p</p>
<p>使用p去寻找左孩子和右孩子，先入左孩子再入右孩子，然后由于p被原来的p重新赋值，因为入队时左孩子先入的队，所以出队时左孩子先被拿出来。</p>
<h3 id="6-树的双亲表示法"><a href="#6-树的双亲表示法" class="headerlink" title="6.树的双亲表示法"></a>6.树的双亲表示法</h3><p><img src="http://c.biancheng.net/uploads/allimg/190427/0954102449-0.gif" alt="普通树存储结构"></p>
<p>双亲表示法采用<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3334.html">顺序表</a>（也就是数组）存储普通树，其实现的核心思想是：顺序存储各个节点的同时，给各节点附加一个记录其父节点位置的变量。</p>
<p>注意，根节点没有父节点（父节点又称为双亲节点），因此根节点记录父节点位置的变量通常置为 -1。</p>
<p>例如，采用双亲表示法存储图 1 中普通树，其存储状态如图 2 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/09541054R-1.gif" alt="双亲表示法存储普通树示意图"><br>图 2 双亲表示法存储普通树示意图</p>
<p>C语言知识补充：</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="type">int</span> parent;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Node node[MAX_SIZE];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">&#125;Tree;</span><br><span class="line">Tree <span class="title function_">initTree</span><span class="params">(Tree	tree)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入结点个数：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(tree.n));</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;请输入结点的值其双亲位于数组中的位置下标:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tree.n;i++)&#123;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c %d&quot;</span>,&amp;ch,&amp;j);</span><br><span class="line">		tree.node[i].data=ch;</span><br><span class="line">		tree.node[i].parent=j;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FindParent</span><span class="params">(Tree tree)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="type">int</span> isifind=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你要查找的结点值&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tree.n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(tree.node[i].data==a)&#123;</span><br><span class="line">			isifind=<span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> ad=tree.node[i].parent;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c该字节的父节点为%c,下标为%d&quot;</span>,a,tree.node[ad].data,ad);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 		<span class="keyword">if</span> (isifind == <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;树中无此节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    Tree tree;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_SIZE; i++) &#123;</span><br><span class="line">        tree.node[i].data = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        tree.node[i].parent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    tree = initTree(tree);</span><br><span class="line">    FindParent(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h3 id="7-树的孩子表达法-skip"><a href="#7-树的孩子表达法-skip" class="headerlink" title="7.树的孩子表达法(skip)"></a>7.树的孩子表达法(skip)</h3><p>孩子表示法存储普通树采用的是 “<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3334.html">顺序表</a>+<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3336.html">链表</a>“ 的组合结构，其存储过程是：从树的根节点开始，使用顺序表依次存储树中各个节点，需要注意的是，与双亲表示法不同，孩子表示法会给各个节点配备一个链表，用于存储各节点的孩子节点位于顺序表中的位置。</p>
<p>如果节点没有孩子节点（叶子节点），则该节点的链表为空链表。</p>
<p>例如，使用孩子表示法存储图 1a) 中的普通树，则最终存储状态如图 1b) 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/0954501N3-0.gif" alt="img"><br>图 1 孩子表示法存储普通树示意图</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TElemType char</span></span><br><span class="line"><span class="comment">//孩子表示法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> child;<span class="comment">//链表中每个结点存储的不是数据本身，而是数据在数组中存储的位置下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//结点的数据类型</span></span><br><span class="line">    ChildPtr* firstchild;<span class="comment">//孩子链表的头指针</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_SIZE];<span class="comment">//存储结点的数组</span></span><br><span class="line">    <span class="type">int</span> n, r;<span class="comment">//结点数量和树根的位置</span></span><br><span class="line">&#125;CTree;</span><br><span class="line"><span class="comment">//孩子表示法存储普通树</span></span><br><span class="line">CTree <span class="title function_">initTree</span><span class="params">(CTree tree)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入节点数量：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(tree.n));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tree.n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第 %d 个节点的值：\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;(tree.nodes[i].data));</span><br><span class="line">        tree.nodes[i].firstchild = (ChildPtr*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ChildPtr));</span><br><span class="line">        tree.nodes[i].firstchild-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入节点 %c 的孩子节点数量：\n&quot;</span>, tree.nodes[i].data);</span><br><span class="line">        <span class="type">int</span> Num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Num);</span><br><span class="line">        <span class="keyword">if</span> (Num != <span class="number">0</span>) &#123;</span><br><span class="line">            ChildPtr * p = tree.nodes[i].firstchild;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Num; j++) &#123;</span><br><span class="line">                ChildPtr * newEle = (ChildPtr*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ChildPtr));</span><br><span class="line">                newEle-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;输入第 %d 个孩子节点在顺序表中的位置&quot;</span>, j + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(newEle-&gt;child));</span><br><span class="line">                p-&gt;next = newEle;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">findKids</span><span class="params">(CTree tree, <span class="type">char</span> a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hasKids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tree.n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree.nodes[i].data == a) &#123;</span><br><span class="line">            ChildPtr * p = tree.nodes[i].firstchild-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                hasKids = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, tree.nodes[p-&gt;child].data);</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasKids == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;此节点为叶子节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    CTree tree;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++) &#123;</span><br><span class="line">        tree.nodes[i].firstchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree = initTree(tree);</span><br><span class="line">    <span class="comment">//默认数根节点位于数组notes[0]处</span></span><br><span class="line">    tree.r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;找出节点 F 的所有孩子节点：&quot;</span>);</span><br><span class="line">    findKids(tree, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-树的孩子兄弟表示法：-简单"><a href="#8-树的孩子兄弟表示法：-简单" class="headerlink" title="8.树的孩子兄弟表示法：(简单)"></a>8.树的孩子兄弟表示法：(简单)</h3><p>孩子兄弟表示法。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/09552W405-0.gif" alt="普通树示意图"><br>图 1 普通树示意图</p>
<p>树结构中，位于同一层的节点之间互为兄弟节点。例如，图 1 的普通树中，节点 A、B 和 C 互为兄弟节点，而节点 D、E 和 F 也互为兄弟节点。</p>
<p>孩子兄弟表示法，采用的是<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3336.html">链式存储结构</a>，其存储树的实现思想是：从树的根节点开始，依次用<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3336.html">链表</a>存储各个节点的孩子节点和兄弟节点。</p>
<p>因此，该链表中的节点应包含以下 3 部分内容（如图 2 所示）：</p>
<ol>
<li>节点的值；</li>
<li>指向孩子节点的指针；</li>
<li>指向兄弟节点的指针；</li>
</ol>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/09552RJ6-1.gif" alt="节点结构示意图"><br>图 2 节点结构示意图</p>
<p>用 C 语言代码表示节点结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType char</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span>   </span><br><span class="line">    ElemType data;   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> * <span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>


<p>以图 1 为例，使用孩子兄弟表示法进行存储的结果如图 3 所示:</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/09552Q340-2.gif" alt="孩子兄弟表示法示意图"><br>图 3 孩子兄弟表示法示意图</p>
<p>由图 3 可以看到，节点 R 无兄弟节点，其孩子节点是 A；节点 A 的兄弟节点分别是 B 和 C，其孩子节点为 D，依次类推。</p>
<p>实现图 3 中的 C 语言实现代码也很简单，根据图中链表的结构即可轻松完成链表的创建和使用，因此不再给出具体代码。</p>
<p>接下来观察图 1 和图 3。图 1 为原普通树，图 3 是由图 1 经过孩子兄弟表示法转化而来的一棵树，确切地说，图 3 是一棵<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3384.html">二叉树</a>。因此可以得出这样一个结论，即通过孩子兄弟表示法，任意一棵普通树都可以相应转化为一棵二叉树，换句话说，任意一棵普通树都有唯一的一棵二叉树于其对应。</p>
<p>因此，孩子兄弟表示法可以作为将普通树转化为二叉树的最有效方法，通常又被称为”二叉树表示法”或”二叉链表表示法”。</p>
<h3 id="9-哈夫曼树"><a href="#9-哈夫曼树" class="headerlink" title="9.哈夫曼树"></a>9.哈夫曼树</h3><h4 id="1-哈夫曼树相关的几个名词"><a href="#1-哈夫曼树相关的几个名词" class="headerlink" title="1.哈夫曼树相关的几个名词"></a>1.哈夫曼树相关的几个名词</h4><p><strong>路径</strong>：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。</p>
<p><strong>路径长度</strong>：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，<strong>规定根结点所在层数为1层</strong>，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。</p>
<p><strong>结点的权</strong>：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。</p>
<p><strong>结点的带权路径长度</strong>：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 &#x3D; 10 。</p>
<p>树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如图 1 中所示的这颗树的带权路径长度为：</p>
<blockquote>
<p>WPL &#x3D; 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3</p>
</blockquote>
<h4 id="2-什么是哈夫曼树"><a href="#2-什么是哈夫曼树" class="headerlink" title="2.什么是哈夫曼树"></a>2.什么是哈夫曼树</h4><p>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。</p>
<p>在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。</p>
<h4 id="3-构建哈夫曼树的过程"><a href="#3-构建哈夫曼树的过程" class="headerlink" title="3.构建哈夫曼树的过程"></a>3.构建哈夫曼树的过程</h4><p>对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：</p>
<ol>
<li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li>
<li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</li>
<li>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li>
</ol>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/09563QS5-1.png" alt="img"></p>
<p>图 2 哈夫曼树的构建过程</p>
<p>图 2 中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 &#x3D; 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。</p>
<h4 id="4-哈弗曼树中结点结构"><a href="#4-哈弗曼树中结点结构" class="headerlink" title="4.哈弗曼树中结点结构"></a>4.哈弗曼树中结点结构</h4><p>构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。</p>
<p>所以，哈夫曼树中结点构成用代码表示为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈夫曼树结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    </span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//结点权重    </span></span><br><span class="line">    <span class="type">int</span> parent, left, right;<span class="comment">//父结点、左孩子、右孩子在数组中的位置下标</span></span><br><span class="line">  &#125;HTNode, *HuffmanTree;</span><br></pre></td></tr></table></figure>

<h4 id="5-构建哈弗曼树的算法实现"><a href="#5-构建哈弗曼树的算法实现" class="headerlink" title="5.构建哈弗曼树的算法实现"></a>5.构建哈弗曼树的算法实现</h4><p>构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。</p>
<p>查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：</p>
<ul>
<li>如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；</li>
<li>如果介于两个结点权重值之间，替换原来较大的结点；</li>
</ul>
<p>实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HT数组中存放的哈夫曼树，end表示HT数组中存放结点的最终位置，s1和s2传递的是HT数组中权重值最小的两个结点在数组中的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Select</span><span class="params">(HuffmanTree HT, <span class="type">int</span> end, <span class="type">int</span> *s1, <span class="type">int</span> *s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> min1, min2;</span><br><span class="line">    <span class="comment">//遍历数组初始下标为 1</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找到还没构建树的结点</span></span><br><span class="line">    <span class="keyword">while</span>(HT[i].parent != <span class="number">0</span> &amp;&amp; i &lt;= end)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    min1 = HT[i].weight;</span><br><span class="line">    *s1 = i;</span><br><span class="line">   </span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">while</span>(HT[i].parent != <span class="number">0</span> &amp;&amp; i &lt;= end)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对找到的两个结点比较大小，min2为大的，min1为小的</span></span><br><span class="line">    <span class="keyword">if</span>(HT[i].weight &lt; min1)&#123;</span><br><span class="line">        min2 = min1;</span><br><span class="line">        *s2 = *s1;</span><br><span class="line">        min1 = HT[i].weight;</span><br><span class="line">        *s1 = i;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        min2 = HT[i].weight;</span><br><span class="line">        *s2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个结点和后续的所有未构建成树的结点做比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j &lt;= end; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果有父结点，直接跳过，进行下一个</span></span><br><span class="line">        <span class="keyword">if</span>(HT[j].parent != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果比最小的还小，将min2=min1，min1赋值新的结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(HT[j].weight &lt; min1)&#123;</span><br><span class="line">            min2 = min1;</span><br><span class="line">            min1 = HT[j].weight;</span><br><span class="line">            *s2 = *s1;</span><br><span class="line">            *s1 = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果介于两者之间，min2赋值为新的结点的位置下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HT[j].weight &gt;= min1 &amp;&amp; HT[j].weight &lt; min2)&#123;</span><br><span class="line">            min2 = HT[j].weight;</span><br><span class="line">            *s2 = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：s1和s2传入的是实参的地址，所以函数运行完成后，实参中存放的自然就是哈夫曼树中权重值最小的两个结点在数组中的位置。</p>
</blockquote>
<p>构建哈弗曼树的代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HT为地址传递的存储哈夫曼树的数组，w为存储结点权重值的数组，n为结点个数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanTree</span><span class="params">(HuffmanTree *HT, <span class="type">int</span> *w, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 如果只有一个编码就相当于0</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span>*n<span class="number">-1</span>; <span class="comment">// 哈夫曼树总节点数，n就是叶子结点</span></span><br><span class="line">    *HT = (HuffmanTree) <span class="built_in">malloc</span>((m+<span class="number">1</span>) * <span class="keyword">sizeof</span>(HTNode)); <span class="comment">// 0号位置不用</span></span><br><span class="line">    HuffmanTree p = *HT;</span><br><span class="line">    <span class="comment">// 初始化哈夫曼树中的所有结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (p+i)-&gt;weight = *(w+i<span class="number">-1</span>);</span><br><span class="line">        (p+i)-&gt;parent = <span class="number">0</span>;</span><br><span class="line">        (p+i)-&gt;left = <span class="number">0</span>;</span><br><span class="line">        (p+i)-&gt;right = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从树组的下标 n+1 开始初始化哈夫曼树中除叶子结点外的结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n+<span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (p+i)-&gt;weight = <span class="number">0</span>;</span><br><span class="line">        (p+i)-&gt;parent = <span class="number">0</span>;</span><br><span class="line">        (p+i)-&gt;left = <span class="number">0</span>;</span><br><span class="line">        (p+i)-&gt;right = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n+<span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s1, s2;</span><br><span class="line">        Select(*HT, i<span class="number">-1</span>, &amp;s1, &amp;s2);</span><br><span class="line">        (*HT)[s1].parent = (*HT)[s2].parent = i;</span><br><span class="line">        (*HT)[i].left = s1;</span><br><span class="line">        (*HT)[i].right = s2;</span><br><span class="line">        (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果使用此程序，对权重值分别为 2、8、7、6、5 的节点构建哈夫曼树，最终效果如图 4(A) 所示。但其实，图 4(B) 中显示的哈夫曼树也满足条件，这两棵树的带权路径长度相同。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/09563S1Q-2.png" alt="img"><br>图 4 两种哈夫曼树</p>
<p>之所以使用此程序构建的哈夫曼树，是图 4(A) 而不是 4(B)，是因为在构建哈夫曼树时，结点 2 和结点 5 构建的新的结点 7 存储在动态树组中位置，比权重值为 7 节点的存储位置还靠后，所以，在程序继续选择两个权值最小的结点时，直接选择了的叶子结点 6 和 7 。</p>
<h2 id="八、散列表"><a href="#八、散列表" class="headerlink" title="八、散列表"></a>八、散列表</h2><h2 id="九、堆（优先队列）"><a href="#九、堆（优先队列）" class="headerlink" title="九、堆（优先队列）"></a>九、堆（优先队列）</h2><h2 id="十、查找"><a href="#十、查找" class="headerlink" title="十、查找"></a>十、查找</h2><p><strong>分为静态查找和动态查找</strong></p>
<ul>
<li>在查找表中只做查找操作，而不改动表中数据元素，称此类查找表为静态查找表；</li>
<li>在查找表中做查找操作的同时进行插入数据或者删除数据的操作，称此类表为动态查找表。</li>
</ul>
<p>静态查找表既可以使用顺序表表示，也可以使用链表结构表示。虽然一个是数组、一个链表，但两者在做查找操作时，基本上大同小异。</p>
<h3 id="1-顺序查找的实现："><a href="#1-顺序查找的实现：" class="headerlink" title="1.顺序查找的实现："></a>1.顺序查找的实现：</h3><p>静态查找表用顺序存储结构表示时，顺序查找的查找过程为：从表中的最后一个数据元素开始，逐个同记录的关键字做比较，如果匹配成功，则查找成功；反之，如果直到表中第一个关键字查找完也没有成功匹配，则查找失败。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    keyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Create</span><span class="params">(SSTable **st,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	(*st)=(SSTable*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SSTable));</span><br><span class="line">	(*st)-&gt;length=length;</span><br><span class="line">	(*st)-&gt;elem=(ElemType*)<span class="built_in">malloc</span>((length+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=length;i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;输入表中的数据&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;((*st)-&gt;elem[i].key)); </span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(SSTable *st,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=st-&gt;length;</span><br><span class="line">	st-&gt;elem[<span class="number">0</span>].key=key;</span><br><span class="line">	<span class="keyword">while</span>(st-&gt;elem[i].key!=key)&#123;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	SSTable *st;</span><br><span class="line"> 	<span class="type">int</span> key;</span><br><span class="line"> 	<span class="type">int</span> location;</span><br><span class="line">    Create(&amp;st, <span class="number">6</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入查找数据的关键字：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">    location=search(st, key);</span><br><span class="line">    <span class="keyword">if</span> (location==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数据在查找表中的位置为：%d&quot;</span>,location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要特别注意指针数组的用法。</p>
<h4 id="顺序查找的性能分析"><a href="#顺序查找的性能分析" class="headerlink" title="顺序查找的性能分析"></a>顺序查找的性能分析</h4><p>查找操作的性能分析主要考虑其<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3332.html">时间复杂度</a>，而整个查找过程其实大部分时间花费在关键字和查找表中的数据进行比较上。</p>
<p>所以查找算法衡量好坏的依据为：查找成功时，查找的关键字和查找表中的数据元素中进行过比较的个数的平均值，称为平均查找长度（Average Search Length，用 ASL 表示）。</p>
<p>例如，对于具有 n 个数据元素的查找表，查找成功的平均查找长度的计算公式为：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/103345H43-1.png" alt="img"></p>
<p>Pi 为第 i 个数据元素被查找的概率，所有元素被查找的概率的和为 1；Ci 表示在查找到第 i 个数据元素之前已进行过比较的次数。若表中有 n 个数据元素，查找第一个元素时需要比较 n 次；查找最后一个元素时需要比较 1 次，所以有 <code>Ci = n – i + 1</code> 。</p>
<p>一般情况，表中各数据元素被查找的概率是未知的。假设含有 n 个数据元素的查找表中，各数据被查找的概率是相同的，则：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/1033456003-2.png" alt="img"></p>
<p>换算后，得：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/1033455261-3.png" alt="img"></p>
<blockquote>
<p>如果对于查找表中各个数据元素有可能被查找的概率提前已知，就应该根据其查找概率的大小对查找表中的数据元素进行适当的调整：被查找概率越大，离查找出发点 i 越近；反之，越远。这样可以适当的减少查找操作中的比较次数。</p>
</blockquote>
<p>上边的平均查找长度是在假设查找算法每次都成功的前提下得出的。而对于查找算法来说，查找成功和查找失败的概率是相同的。所以，查找算法的平均查找长度应该为查找成功时的平均查找长度加上查找失败时的平均查找长度。</p>
<p>对于含有 n 个数据的表来说，每次查找失败，比较的次数都是 n+1。所以查找算法的平均查找长度的计算公式为：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/10334540B-4.png" alt="img"></p>
<h3 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2.二分查找"></a>2.二分查找</h3><p>折半查找，也称二分查找，在某些情况下相比于顺序查找，使用折半查找算法的效率更高。但是该算法的使用的前提是静态<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3426.html">查找表</a>中的数据必须是有序的。</p>
<p>例如，在<code>&#123;5,21,13,19,37,75,56,64,88 ,80,92&#125;</code>这个查找表使用折半查找算法查找数据之前，需要首先对该表中的数据按照所查的关键字进行排序：<code>&#123;5,13,19,21,37,56,64,75,80,88,92&#125;</code>。</p>
<blockquote>
<p>在折半查找之前对查找表按照所查的关键字进行排序的意思是：若查找表中存储的数据元素含有多个关键字时，使用哪种关键字做折半查找，就需要提前以该关键字对所有数据进行排序。</p>
</blockquote>
<h4 id="折半查找算法"><a href="#折半查找算法" class="headerlink" title="折半查找算法"></a>折半查找算法</h4><p>对静态查找表<code>&#123;5,13,19,21,37,56,64,75,80,88,92&#125;</code>采用折半查找算法查找关键字为 21 的过程为：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/103504K13-0.png" alt="img"><br>图 1 折半查找的过程（a）</p>
<p>如上图 1 所示，指针 low 和 high 分别指向查找表的第一个关键字和最后一个关键字，指针 mid 指向处于 low 和 high 指针中间位置的关键字。在查找的过程中每次都同 mid 指向的关键字进行比较，由于整个表中的数据是有序的，因此在比较之后就可以知道要查找的关键字的大致位置。</p>
<p>例如在查找关键字 21 时，首先同 56 作比较，由于<code>21 &lt; 56</code>，而且这个查找表是按照升序进行排序的，所以可以判定如果静态查找表中有 21 这个关键字，就一定存在于 low 和 mid 指向的区域中间。</p>
<p>因此，再次遍历时需要更新 high 指针和 mid 指针的位置，令 high 指针移动到 mid 指针的左侧一个位置上，同时令 mid 重新指向 low 指针和 high 指针的中间位置。如图 2 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/1035044C1-1.png" alt="img"><br>图 2 折半查找的过程（b）</p>
<p>同样，用 21 同 mid 指针指向的 19 作比较，<code>19 &lt; 21</code>，所以可以判定 21 如果存在，肯定处于 mid 和 high 指向的区域中。所以令 low 指向 mid 右侧一个位置上，同时更新 mid 的位置。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/103504O23-2.png" alt="img"><br>图 3 折半查找的过程（3）</p>
<p>当第三次做判断时，发现 mid 就是关键字 21 ，查找结束。</p>
<blockquote>
<p>注意：在做查找的过程中，如果 low 指针和 high 指针的中间位置在计算时位于两个关键字中间，即求得 mid 的位置不是整数，需要统一做取整操作。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    keyType key;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Create</span><span class="params">(SSTable **st,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	(*st)=(SSTable*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SSTable));</span><br><span class="line">	(*st)-&gt;length=length;</span><br><span class="line">	(*st)-&gt;elem=(ElemType*)<span class="built_in">malloc</span>((length+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=length;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入表中的数据&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;((*st)-&gt;elem[i].key));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Bin</span><span class="params">(SSTable *st,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="type">int</span> low=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> hight=st-&gt;length;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=hight)&#123;</span><br><span class="line">		mid=(low+hight)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(key&lt;(st-&gt;elem[mid].key))&#123;</span><br><span class="line">			hight=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>((st-&gt;elem[mid].key)&lt;key)&#123;</span><br><span class="line">			low=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SSTable *st;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> location;</span><br><span class="line">    Create(&amp;st, <span class="number">11</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入查找数据的关键字：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">    location=Search_Bin(st, key);</span><br><span class="line">    <span class="keyword">if</span> (location==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找表中无该元素&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数据在查找表中的位置为：%d&quot;</span>,location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="折半查找的性能分析"><a href="#折半查找的性能分析" class="headerlink" title="折半查找的性能分析"></a>折半查找的性能分析</h4><p>折半查找的运行过程可以用<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3384.html">二叉树</a>来描述，这棵树通常称为“判定树”。例如图 1 中的静态查找表中做折半查找的过程，对应的判定树如图 4：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/103504J25-3.gif" alt="折半查找对应的判定树"><br>图 4 折半查找对应的判定树</p>
<p>注意，此图中叶子节点看似为父节点的右孩子节点，其实不然，这里的叶子节点既可以作为右孩子节点，也可以当作左孩子节点对待，都是可以的。</p>
<p>在判定树中可以看到，如果想在查找表中查找 21 的位置，只需要进行 3 次比较，依次和 56、19、21 进行比较，而比较的次数恰好是该关键字所在判定树中的层次（关键字 21 在判定树中的第 3 层）。</p>
<p>对于具有 n 个结点（查找表中含有 n 个关键字）的判定树，它的层次数至多为：<code>log2n + 1</code>（如果结果不是整数，则做取整操作，例如： <code>log211 +1 = 3 + 1 = 4</code> ）。</p>
<p>同时，在查找表中各个关键字被查找概率相同的情况下，折半查找的平均查找长度为：<code>ASL = log2(n+1) – 1</code>。</p>
<h2 id="十一、排序算法"><a href="#十一、排序算法" class="headerlink" title="十一、排序算法"></a>十一、排序算法</h2><h2 id="十二、图"><a href="#十二、图" class="headerlink" title="十二、图"></a>十二、图</h2><h3 id="1-图的性质"><a href="#1-图的性质" class="headerlink" title="1.图的性质"></a>1.图的性质</h3><p>我们知道，数据之间的关系有 3 种，分别是 “一对一”、”一对多” 和 “多对多”，前两种关系的数据可分别用<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3333.html">线性表</a>和树结构存储，本节学习存储具有”多对多”逻辑关系数据的结构——图存储结构。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/10033362W-0.gif" alt="图存储结构示意图"><br>图 1 图存储结构示意图</p>
<p>图 1 所示为存储 V1、V2、V3、V4 的图结构，从图中可以清楚的看出数据之间具有的”多对多”关系。例如，V1 与 V4 和 V2 建立着联系，V4 与 V1 和 V3 建立着联系，以此类推。</p>
<p>与<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3336.html">链表</a>不同，图中<strong>存储的各个数据元素被称为顶点（而不是节点）</strong>。拿图 1 来说，该图中含有 4 个顶点，分别为顶点 V1、V2、V3 和 V4。</p>
<p>图存储结构中，习惯上用 Vi 表示图中的顶点，且所有顶点构成的集合通常用 V 表示，如图 1 中顶点的集合为 V&#x3D;{V1,V2,V3,V4}。</p>
<p>注意，图 1 中的图仅是图存储结构的其中一种，数据之间 “多对多” 的关系还可能用如图 2 所示的图结构表示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/1003336014-1.gif" alt="有向图示意图"><br>图 2 有向图示意图</p>
<p>可以看到，各个顶点之间的关系并不是”双向”的。比如，V4 只与 V1 存在联系（从 V4 可直接找到 V1），而与 V3 没有直接联系；同样，V3 只与 V4 存在联系（从 V3 可直接找到 V4），而与 V1 没有直接联系，以此类推。</p>
<p>因此，图存储结构可细分两种表现类型，分别为无向图（图 1）和有向图（图 2）。</p>
<h3 id="2-图存储结构基本常识"><a href="#2-图存储结构基本常识" class="headerlink" title="2.图存储结构基本常识"></a>2.图存储结构基本常识</h3><h4 id="弧头和弧尾"><a href="#弧头和弧尾" class="headerlink" title="弧头和弧尾"></a>弧头和弧尾</h4><p>有向图中，无箭头一端的顶点通常被称为”初始点”或”弧尾”，箭头直线的顶点被称为”终端点”或”弧头”。</p>
<h4 id="入度和出度"><a href="#入度和出度" class="headerlink" title="入度和出度"></a>入度和出度</h4><p>对于有向图中的一个顶点 V 来说，<strong>箭头指向 V 的弧的数量为 V 的入度（InDegree，记为 ID(V)）</strong>；<strong>箭头远离 V 的弧的数量为 V 的出度（OutDegree，记为OD(V)）</strong>。拿图 2 中的顶点 V1来说，<strong>该顶点的入度为 1，出度为 2（该顶点的度为 3）</strong>。</p>
<h4 id="V1-V2-和-的区别"><a href="#V1-V2-和-的区别" class="headerlink" title="(V1,V2) 和 &lt;V1,V2&gt; 的区别"></a>(V1,V2) 和 &lt;V1,V2&gt; 的区别</h4><p>无向图中描述两顶点（V1 和 V2）之间的关系可以用 (V1,V2) 来表示，而有向图中描述从 V1 到 V2 的”单向”关系用 &lt;V1,V2&gt; 来表示。</p>
<p>由于图存储结构中顶点之间的关系是用线来表示的，因此 (V1,V2) 还可以用来表示无向图中连接 V1 和 V2 的线，又称为边；同样，&lt;V1,V2&gt; 也可用来表示有向图中从 V1 到 V2 带方向的线，又称为弧。</p>
<h4 id="集合-VR-的含义"><a href="#集合-VR-的含义" class="headerlink" title="集合 VR 的含义"></a>集合 VR 的含义</h4><p>并且，图中习惯用 <strong>VR 表示图中所有顶点之间关系的集合</strong>。例如，图 1 中无向图的集合 VR&#x3D;{(v1,v2),(v1,v4),(v1,v3),(v3,v4)}，图 2 中有向图的集合 VR&#x3D;{&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;}。</p>
<h4 id="路径和回路"><a href="#路径和回路" class="headerlink" title="路径和回路"></a>路径和回路</h4><p>无论是无向图还是有向图，从<strong>一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径</strong>。如果路径中<strong>第一个顶点和最后一个顶点相同，则此路径称为”回路”（或”环”）</strong>。</p>
<p>并且，<strong>若路径中各顶点都不重复</strong>，此路径又被称为”<strong>简单路径</strong>“；同样，<strong>若回路中的顶点互不重复</strong>，此回路被称为”<strong>简单回路</strong>“（或简单环）。</p>
<p>拿图 1 来说，从 V1 存在一条路径还可以回到 V1，此路径为 {V1,V3,V4,V1}，这是一个回路（环），而且还是一个简单回路（简单环）。</p>
<p>在有向图中，每条路径或回路都是有方向的。</p>
<h4 id="权和网的含义"><a href="#权和网的含义" class="headerlink" title="权和网的含义"></a>权和网的含义</h4><p>在某些实际场景中，图中的每条边（或弧）会赋予一个实数来表示一定的含义，这种与边（或弧）相匹配的实数被称为”权”，而<strong>带权的图通常称为网</strong>。如图 3 所示，就是一个网结构：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/1003334M8-2.gif" alt="带权的图存储结构"><br>图 3 带权的图存储结构</p>
<p>子图：指的是由图中一部分顶点和边构成的图，称为原图的子图。</p>
<h3 id="3-图存储结构的分类"><a href="#3-图存储结构的分类" class="headerlink" title="3.图存储结构的分类"></a>3.图存储结构的分类</h3><p>根据不同的特征，图又可分为完全图，<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3405.html">连通图</a>、稀疏图和稠密图：</p>
<ul>
<li><p>完全图：<strong>若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为</strong></p>
<p>完全图</p>
<p>（如图 4a)）。同时，满足此条件的有向图则称为</p>
<p>有向完全图</p>
<p>（图 4b)）。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/1003336434-3.gif" alt="完全图示意图"><br>图 4 完全图示意图</p>
<p>**具有 n 个顶点的完全图，图中边的数量为 n(n-1)&#x2F;2；而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)**。（重要）</p>
</li>
<li><p>稀疏图和稠密图：这两种图是相对存在的，**即如果图中具有很少的边（或弧），此图就称为”稀疏图”；反之，则称此图为”稠密图”**。</p>
</li>
<li><p>稀疏和稠密的判断条件是：e&lt;nlogn，其中 e 表示图中边（或弧）的数量，n 表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。</p>
</li>
</ul>
<h3 id="4-连通图"><a href="#4-连通图" class="headerlink" title="4.连通图"></a>4.连通图</h3><p>前面讲过，图中从一个顶点到达另一顶点，若存在至少一条路径，则称这两个顶点是连通着的。例如图 1 中，虽然 V1 和 V3 没有直接关联，但从 V1 到 V3 存在两条路径，分别是 <code>V1-V2-V3</code> 和 <code>V1-V4-V3</code>，因此称 V1 和 V3 之间是连通的。</p>
<p>  <img src="http://c.biancheng.net/uploads/allimg/190427/1004124516-0.gif" alt="顶点之间的连通状态示意图"><br>  图 1 顶点之间的连通状态示意图</p>
<p>  <strong>无向图中，如果任意两个顶点之间都能够连通，则称此无向图为连通图。</strong>例如，图 2 中的无向图就是一个连通图，因为此图中任意两顶点之间都是连通的。</p>
<p>  <img src="http://c.biancheng.net/uploads/allimg/190427/1004121044-1.gif" alt="连通图示意图"><br>  图 2 连通图示意图</p>
<p>  <strong>若无向图不是连通图，但图中存储某个子图符合连通图的性质，则称该子图为连通分量。</strong></p>
<p>  前面讲过，由图中部分顶点和边构成的图为该图的一个子图，但这里的子图指的是图中”最大”的连通子图（也称”极大连通子图”）。</p>
<p>  如图 3 所示，虽然图 3a) 中的无向图不是连通图，但可以将其分解为 3 个”最大子图”（图 3b)），它们都满足连通图的性质，因此都是连通分量。</p>
<p>  <img src="http://c.biancheng.net/uploads/allimg/190427/100412N47-2.gif" alt="img"><br>  图 3 连通分量示意图</p>
<p>  提示，图 3a) 中的无向图只能分解为 3 部分各自连通的”最大子图”。</p>
<p>  需要注意的是，连通分量的提出是以”<strong>整个无向图不是连通图”为前提的</strong>，因为如果无向图是连通图，则其无法分解出多个最大连通子图，因为图中所有的顶点之间都是连通的。</p>
<h4 id="1-强连通图"><a href="#1-强连通图" class="headerlink" title="1.强连通图"></a>1.强连通图</h4><p>  有向图中，若任意两个顶点 Vi 和 Vj，满足从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，也就是都含有至少一条通路，则称此有向图为强连通图。如图 4 所示就是一个强连通图。</p>
<p>  <img src="http://c.biancheng.net/uploads/allimg/190427/10041212U-3.gif" alt="强连通图"><br>  图 4 强连通图</p>
<p>  与此同时，若有向图本身不是强连通图，但其包含的最大连通子图具有强连通图的性质，则称该子图为强连通分量。</p>
<p>  <img src="http://c.biancheng.net/uploads/allimg/190427/1004125C0-4.gif" alt="强连通分量"><br>  图 5 强连通分量</p>
<p>  如图 5 所示，整个有向图虽不是强连通图，但其含有两个强连通分量。</p>
<p>  可以这样说，连通图是在无向图的基础上对图中顶点之间的连通做了更高的要求，而强连通图是在有向图的基础上对图中顶点的连通做了更高的要求。</p>
<h3 id="5-生成树（不一定是V1断开生成树）"><a href="#5-生成树（不一定是V1断开生成树）" class="headerlink" title="5.生成树（不一定是V1断开生成树）"></a>5.生成树（不一定是V1断开生成树）</h3><p>对连通图进行遍历，过程中所经过的边和顶点的组合可看做是一棵普通树，通常称为生成树。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/100500J58-0.gif" alt="连通图及其对应的生成树"><br>图 1 连通图及其对应的生成树</p>
<p>如图 1 所示，图 1a) 是一张连通图，图 1b) 是其对应的 2 种生成树。</p>
<p>连通图中，由于任意两顶点之间可能含有多条通路，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。</p>
<p>连通图中的生成树必须满足以下 2 个条件：</p>
<ol>
<li><strong>包含连通图中所有的顶点；</strong></li>
<li><strong>任意两顶点之间有且仅有一条通路；</strong></li>
</ol>
<p>因此，连通图的生成树具有这样的特征，<strong>即生成树中<code>边的数量 = 顶点数 - 1</code>。</strong></p>
<h4 id="生成森林"><a href="#生成森林" class="headerlink" title="生成森林"></a>生成森林</h4><p><strong>生成树是对应连通图来说，而生成森林是对应非连通图来说的。</strong></p>
<p>我们知道，非连通图可分解为多个连通分量，而每个连通分量又各自对应多个生成树（至少是 1 棵），因此与整个非连通图相对应的，是由多棵生成树组成的生成森林。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/1005001107-1.gif" alt="非连通图和连通分量"><br>图 2 非连通图和连通分量</p>
<p>如图 2 所示，这是一张非连通图，可分解为 3 个连通分量，其中各个连通分量对应的生成树如图 3 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/100500G18-2.gif" alt="生成森林"><br>图 3 生成森林</p>
<p>注意，图 3 中列出的仅是各个连通分量的其中一种生成树。</p>
<p>因此，多个连通分量对应的多棵生成树就构成了整个非连通图的生成森林。</p>
<h2 id="十三、-补充"><a href="#十三、-补充" class="headerlink" title="十三、 补充"></a>十三、 补充</h2><p>静态分配的内存在栈里，每进入一个函数时都会建栈，栈里会存放函数用到的参数、局部变量等信息，函数执行完以后，会出栈销毁栈，这个过程就会释放你静态分配的数组内存，这是由系统自动完成的。</p>
<p>动态分配的内存，实际在堆上，系统没法自动帮你去释放堆上的内存，需要你自己写free或者delete来告诉操作系统需要帮你去释放堆上哪个位置的内存。</p>
<p><strong>realloc和malloc的区别:</strong></p>
<p>一、分配不同</p>
<p>1、malloc函数：malloc函数对没有分配过的内存块直接进行分配。</p>
<p>2、realloc函数：realloc函数是在已经分配好的内存块重新进行分配。</p>
<p>二、释放不同</p>
<p>1、malloc函数：malloc函数分配好的内存块一般要用free(size_t size)来释放内存块。</p>
<p>2、realloc函数：realloc函数分配好的内存块不需要用free(size_t size)来释放内存块。</p>
<p>三、强制转化不同</p>
<p>1、malloc函数：malloc函数需要强制转化。</p>
<p>2、realloc函数：realloc函数不需要强制转化。</p>
<p><strong>递归一个重要东西：（重点，重点，重点！！！！！！）</strong></p>
<p><strong>在无返回值的函数中使用return是跳出调用的函数，继续执行原来要执行的语句。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">huangxinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">http://example.com/2024/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">天上星星亮晶晶</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://typora-1328334712.cos.ap-beijing.myqcloud.com/img/R-C.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/03/SpringMVC/" title="SpringMvc"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringMvc</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/03/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/" title="C语言程序设计基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C语言程序设计基础</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora-1328334712.cos.ap-beijing.myqcloud.com/img/R-C.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">huangxinjian</div><div class="author-info__description">huangxinjian的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BC%95%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">一、数据结构引论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.数据结构的基本概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.数据的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.算法及其描述：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">二、线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%88%E6%95%B0%E6%8D%AE%E9%A1%BA%E5%BA%8F%E5%AD%98%E6%94%BE%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.线性表的线性存储结构（数据顺序存放）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E6%95%A3%E5%AD%98%E6%94%BE%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.线性表的链式存储结构（数据分散存放）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC%EF%BC%9A%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.单链表的反转：（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1、迭代反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">理解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2、递归反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%EF%BC%9A-1"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">理解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%A4%B4%E6%8F%92%E6%B3%95%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">3、头插法反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%B0%B1%E5%9C%B0%E9%80%86%E7%BD%AE%E6%B3%95%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">4、就地逆置法反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%EF%BC%9A-2"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">理解：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.2.5.</span> <span class="toc-text">优缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%9A"><span class="toc-number">1.2.6.</span> <span class="toc-text">4.双向链表：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">1.双向链表的插入操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.双向链表的删除操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">3.双向链表的查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%8C%E5%90%91%E8%A1%A8%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">4.双向表的替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%88%E5%AE%9E%E7%8E%B0%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%EF%BC%89%EF%BC%88%E6%B2%A1%E6%80%9D%E8%B7%AF%E6%B3%A8%E6%84%8F%E7%9C%8B%EF%BC%89"><span class="toc-number">1.2.7.</span> <span class="toc-text">5.循环链表（实现约瑟夫环）（没思路注意看）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%8D%E8%80%83%EF%BC%89"><span class="toc-number">1.2.8.</span> <span class="toc-text">6.双向循环链表（不考）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">三、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%A0%88%EF%BC%88%E8%BF%9B%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.顺序栈（进栈和出栈操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E6%A0%88%EF%BC%88%E8%BF%9B%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.链栈（进栈和出栈操作）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">四、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.顺序队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%89%AF%E7%89%88%EF%BC%9A-%E9%87%8D%E7%82%B9"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">改良版：(重点)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.链式队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.5.</span> <span class="toc-text">五、算法及复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.时间复杂度：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.</span> <span class="toc-text">六、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E9%95%BF%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.定长顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%EF%BC%88%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%89%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.堆分配存储（动态数组实现）（简单）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9D%97%E9%93%BE%E5%AD%98%E5%82%A8%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.块链存储（难）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-BF%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.BF算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%A0%91-%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">七、树(非线性储存方式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.树的性质：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">1.树的结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%90%E6%A0%91%E5%92%8C%E7%A9%BA%E6%A0%91%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">2.子树和空树（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%A6%E5%92%8C%E5%B1%82%E6%AC%A1%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">3.结点的度和层次（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9C%89%E5%BA%8F%E6%A0%91%E5%92%8C%E6%97%A0%E5%BA%8F%E6%A0%91"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">4.有序树和无序树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%A3%AE%E6%9E%97"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">5.森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.1.6.</span> <span class="toc-text">6.树的表示方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.7.1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.二叉树：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">1.二叉树定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">2.二叉树的性质（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">3.满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">4.完全二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.二叉树的顺序存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86-%E9%87%8D%E7%82%B9"><span class="toc-number">1.7.4.</span> <span class="toc-text">5.二叉树遍历(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3%EF%BC%89"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">1.先根遍历（递归思想）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%AD%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">2.中根遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">3.后根遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">4.层次遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%A0%91%E7%9A%84%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.7.5.</span> <span class="toc-text">6.树的双亲表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%A0%91%E7%9A%84%E5%AD%A9%E5%AD%90%E8%A1%A8%E8%BE%BE%E6%B3%95-skip"><span class="toc-number">1.7.6.</span> <span class="toc-text">7.树的孩子表达法(skip)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%A0%91%E7%9A%84%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%9A-%E7%AE%80%E5%8D%95"><span class="toc-number">1.7.7.</span> <span class="toc-text">8.树的孩子兄弟表示法：(简单)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.7.8.</span> <span class="toc-text">9.哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8D%E8%AF%8D"><span class="toc-number">1.7.8.1.</span> <span class="toc-text">1.哈夫曼树相关的几个名词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.7.8.2.</span> <span class="toc-text">2.什么是哈夫曼树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.8.3.</span> <span class="toc-text">3.构建哈夫曼树的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%93%88%E5%BC%97%E6%9B%BC%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.8.4.</span> <span class="toc-text">4.哈弗曼树中结点结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9E%84%E5%BB%BA%E5%93%88%E5%BC%97%E6%9B%BC%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.8.5.</span> <span class="toc-text">5.构建哈弗曼树的算法实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">1.8.</span> <span class="toc-text">八、散列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">九、堆（优先队列）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">1.10.</span> <span class="toc-text">十、查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.顺序查找的实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">顺序查找的性能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.10.2.</span> <span class="toc-text">2.二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">折半查找算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">折半查找的性能分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">十一、排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%9B%BE"><span class="toc-number">1.12.</span> <span class="toc-text">十二、图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.12.1.</span> <span class="toc-text">1.图的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86"><span class="toc-number">1.12.2.</span> <span class="toc-text">2.图存储结构基本常识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%A7%E5%A4%B4%E5%92%8C%E5%BC%A7%E5%B0%BE"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">弧头和弧尾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%BA%A6%E5%92%8C%E5%87%BA%E5%BA%A6"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">入度和出度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V1-V2-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.2.3.</span> <span class="toc-text">(V1,V2) 和 &lt;V1,V2&gt; 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88-VR-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">1.12.2.4.</span> <span class="toc-text">集合 VR 的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%92%8C%E5%9B%9E%E8%B7%AF"><span class="toc-number">1.12.2.5.</span> <span class="toc-text">路径和回路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E5%92%8C%E7%BD%91%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">1.12.2.6.</span> <span class="toc-text">权和网的含义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9B%BE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.12.3.</span> <span class="toc-text">3.图存储结构的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%9E%E9%80%9A%E5%9B%BE"><span class="toc-number">1.12.4.</span> <span class="toc-text">4.连通图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">1.强连通图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AFV1%E6%96%AD%E5%BC%80%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89"><span class="toc-number">1.12.5.</span> <span class="toc-text">5.生成树（不一定是V1断开生成树）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97"><span class="toc-number">1.12.5.1.</span> <span class="toc-text">生成森林</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81-%E8%A1%A5%E5%85%85"><span class="toc-number">1.13.</span> <span class="toc-text">十三、 补充</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" href="/2024/08/03/test/" title="test">test</a><time datetime="2024-08-03T08:05:36.000Z" title="发表于 2024-08-03 16:05:36">2024-08-03</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/08/03/AJAX/" title="AJAX">AJAX</a><time datetime="2024-08-03T08:05:36.000Z" title="发表于 2024-08-03 16:05:36">2024-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/03/Redis%E5%85%A5%E9%97%A8/" title="Redis入门">Redis入门</a><time datetime="2024-08-03T08:05:36.000Z" title="发表于 2024-08-03 16:05:36">2024-08-03</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/08/03/SpringBoot%E5%AD%A6%E4%B9%A0(%E7%8B%82%E7%A5%9E)/" title="SpringBoot">SpringBoot</a><time datetime="2024-08-03T08:05:36.000Z" title="发表于 2024-08-03 16:05:36">2024-08-03</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/08/03/SpringCloud/" title="SpringCloud">SpringCloud</a><time datetime="2024-08-03T08:05:36.000Z" title="发表于 2024-08-03 16:05:36">2024-08-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By huangxinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>